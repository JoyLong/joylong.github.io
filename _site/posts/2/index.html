
<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
	<title>代码萝卜</title>
	<meta name="author" content="Joy Long">

	
	<meta name="description" content="ios-coreanimation Core Animation Advanced Technique 学习笔记(4) 第一部分：下面的图层 5.变换（Transforms） 5.1、仿射变换 5.1.1、仿射变换介绍 之前的例子里有一个钟表的指针， &hellip;">
	

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

	<link href="/atom.xml" rel="alternate" title="代码萝卜" type="application/atom+xml">
	
	<link rel="canonical" href="http://joylong.github.io/posts/2/">
	<link href="/favicon.png" rel="shortcut icon">
	<link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
	<script src="//libs.useso.com/js/jquery/1.7.2/jquery.min.js"></script>
	<link href='http://fonts.useso.com/css?family=Open+Sans:400italic,400,700' rel='stylesheet' type='text/css'>
	
</head>

<script type="text/javascript">

function addBlankTargetForLinks () {

  $('a[href^="http"]').each(function(){

      $(this).attr('target', '_blank');

  });

}

$(document).bind('DOMNodeInserted', function(event) {

  addBlankTargetForLinks();

});

</script>


<body>
	<div class="container">
		<div class="left-col">
			<div class="intrude-less">
			<header id="header" class="inner"><div class="profilepic">	
	<script src="/javascripts/md5.js"></script>
	<script type="text/javascript">
		document.write("<img src='http://www.gravatar.com/avatar/" + MD5("joylong.ly@gmail.com") + "?s=160' alt='Profile Picture' style='width: 160px;' />");
	</script>
</div>
<h1><a href="/">代码萝卜</a></h1>
<p class="subtitle">Joy's coding life.</p>
<nav id="main-nav"><ul class="main">
    <li><a href="/">首页Home</a></li>
    <li><a href="/blog/categories/">分类Categories</a></li>
    <li><a href="/blog/archives">归档Archives</a></li>
    <li><a href="/blog/aboutme.html">关于About</a></li>
</ul></nav>
<nav id="sub-nav">
	<div class="social">
		
		
		
		
		
		
		
		
		
		
		
		
		
		<a class="rss" href="/atom.xml" title="RSS">RSS</a>
		
	</div>
</nav>

</header>				
			</div>
		</div>	
		<div class="mid-col">
			
				
			
			<div class="mid-col-container">
				<div id="content" class="inner">
<div itemscope itemtype="http://schema.org/Blog">


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2014-08-07T00:35:15+08:00" data-updated="true" itemprop="datePublished"></time></div>
		<div class="tags">


	<a class='category' href='/blog/categories/ios-coreanimation/'>ios-coreanimation</a>


</div>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/2014/08/07/core-animation-advanced-technique-4/" itemprop="url">Core Animation Advanced Technique 学习笔记(4)</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<h1>第一部分：下面的图层</h1>

<h2>5.变换（Transforms）</h2>

<h3>5.1、仿射变换</h3>

<h4>5.1.1、仿射变换介绍</h4>

<p>之前的例子里有一个钟表的指针，使用了UIView的<code>transform</code>属性旋转了指针</p>

<p>UIView的transform属性是CGAffineTransform类型，用于在二维空间做<code>旋转</code>，<code>缩放</code>和<code>平移</code>。</p>

<p>CGAffineTransform是一个可以和二维空间向量（例如CGPoint）做乘法变换运算的3X2的矩阵</p>

<p>将CGPoint的每一列和CGAffineTransform矩阵的每一行对应元素相乘再求和，就形成了一个新的CGPoint类型的结果。</p>

<p><strong>但是，CGPoint是1X2的 CGAffineTRansform是3X2的矩阵，没法做矩阵乘法，于是必须要给矩阵填充一些值，这些值主要是让矩阵做乘法，但是不影响运算结果，也不会发生变化</strong></p>

<p>如下图：</p>

<p><img src="http://github-octopress.qiniudn.com/CoreAnimationAdvancedTechnique5.1.png" alt="Mou icon" /></p>

<p>当对图层应用变换矩阵，图层矩形内的每一个点都被相应地做变换，从而形成一个新的四边形的形状。</p>

<p>CGAffineTransform中的“仿射”的意思是无论变换矩阵用什么值，图层中平行的两条线在变换之后任然保持平行，CGAffineTransform可以做出任意符合规则的变换，</p>

<p><img src="http://github-octopress.qiniudn.com/CoreAnimationAdvancedTechnique5.2.png" alt="Mou icon" /></p>

<h4>5.1.2、创建CGAffineTransform</h4>

<p>Core Graphics提供了一系列函数，让毫无数学基础的开发者能够简单地做一些变换。</p>

<p>创建了一个CGAffineTransform实例可以用如下几个函数：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>CGAffineTransformMakeRotation(CGFloat angle)  // 旋转一个角度
</span><span class='line'>CGAffineTransformMakeScale(CGFloat sx, CGFloat sy) // 缩放
</span><span class='line'>CGAffineTransformMakeTranslation(CGFloat tx, CGFloat ty) // 平移，每个点都平移一定距离</span></code></pre></td></tr></table></div></figure>


<p><strong>小例子：把一个图旋转45度</strong></p>

<p>UIView可以通过设置transform属性做变换，但实际上它只是封装了内部图层的变换。</p>

<p>CALayer同样也有一个transform属性，但它的类型是CATransform3D，而不是CGAffineTransform。</p>

<p>CALayer对应于UIView的transform属性叫做<code>affineTransform</code>，</p>

<p>下面的例子是使用affineTransform对图层旋转45度</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@interface ViewController ()
</span><span class='line'>
</span><span class='line'>@property (nonatomic, weak) IBOutlet UIView *layerView;
</span><span class='line'>
</span><span class='line'>@end
</span><span class='line'>
</span><span class='line'>@implementation ViewController
</span><span class='line'>
</span><span class='line'>- (void)viewDidLoad
</span><span class='line'>{
</span><span class='line'>    [super viewDidLoad];
</span><span class='line'>    // 旋转图层45度(这里用的是弧度)
</span><span class='line'>    CGAffineTransform transform = CGAffineTransformMakeRotation(M_PI_4);
</span><span class='line'>    self.layerView.layer.affineTransform = transform;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>@end</span></code></pre></td></tr></table></div></figure>


<p>注：上面旋转设置的都是旋转弧度，可以用以下的宏做换算：</p>

<pre><code>#define RADIANS_TO_DEGREES(x) ((x)/M_PI*180.0) 
#define DEGREES_TO_RADIANS(x) ((x)/180.0*M_PI)
</code></pre>

<h4>5.1.3、组合变换（Combining Transforms）</h4>

<p>旋转，缩放和平移，我们可能不止对图片做一个操作，可能会同时都变换，因此需要创建一个CGAffineTransform类型的空值，矩阵论中称作单位矩阵</p>

<p>Core Graphics同样也提供了一个方便的常量：</p>

<pre><code>CGAffineTransformIdentity
</code></pre>

<p>如果需要混合两个已经存在的变换矩阵，就可以使用如下方法，在两个变换的基础上创建一个新的变换：</p>

<pre><code>CGAffineTransformConcat(CGAffineTransform t1, CGAffineTransform t2);
</code></pre>

<p><strong>小例子，先缩小50%，再旋转30度，最后向右移动200个像素</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)viewDidLoad
</span><span class='line'>{
</span><span class='line'>    [super viewDidLoad];
</span><span class='line'>    // 创建一个新的变换，单位矩阵
</span><span class='line'>    CGAffineTransform transform = CGAffineTransformIdentity; 
</span><span class='line'>    // 缩小50%
</span><span class='line'>    transform = CGAffineTransformScale(transform, 0.5, 0.5); 
</span><span class='line'>    // 旋转30度
</span><span class='line'>    transform = CGAffineTransformRotate(transform, M_PI / 180.0 * 30.0); 
</span><span class='line'>    // 平移200点
</span><span class='line'>    transform = CGAffineTransformTranslate(transform, 200, 0);
</span><span class='line'>    // 应用到图层上
</span><span class='line'>    self.layerView.layer.affineTransform = transform;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h4>5.1.4、剪裁变换(Shear Transform)</h4>

<p>Core Graphics为你提供了计算变换矩阵的一些方法，所以很少需要直接设置CGAffineTransform的值。</p>

<p>除非需要创建一个斜切的变换，但是Core Graphics并没有提供直接的函数。</p>

<p>斜切变换是仿射变换的第四种类型，较于平移，旋转和缩放并不常用（这也是Core Graphics没有提供相应函数的原因），但有些时候也会很有用。</p>

<p>这个变换的效果如下图</p>

<p><img src="http://github-octopress.qiniudn.com/CoreAnimationAdvancedTechnique5.3.png" alt="Mou icon" /></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@implementation ViewController
</span><span class='line'>
</span><span class='line'>CGAffineTransform CGAffineTransformMakeShear(CGFloat x, CGFloat y)
</span><span class='line'>{
</span><span class='line'>    CGAffineTransform transform = CGAffineTransformIdentity;
</span><span class='line'>    transform.c = -x;
</span><span class='line'>    transform.b = y;
</span><span class='line'>    return transform;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>- (void)viewDidLoad
</span><span class='line'>{
</span><span class='line'>    [super viewDidLoad];
</span><span class='line'>    // 倾斜图层到45度
</span><span class='line'>    self.layerView.layer.affineTransform = CGAffineTransformMakeShear(1, 0);
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>@end</span></code></pre></td></tr></table></div></figure>


<h2>5.2、3D变换</h2>

<h3>5.2.1、3D变换介绍</h3>

<p>Core Graphics实际上是一个2D绘图API，并且CGAffineTransform仅仅对2D变换有效。</p>

<p>之前有提到了zPosition属性，可以用来让图层看起来靠近或远离用户，但是transform属性（CATransform3D类型）可以真正让图层在3D空间内移动或者旋转。</p>

<p>和CGAffineTransform类似，CATransform3D也是一个矩阵，但是和2x3的矩阵不同，CATransform3D是一个可以在3维空间内做变换的4x4的矩阵。</p>

<p>下图是对一个3D点做<code>CATransform3D</code>的矩阵变换</p>

<p><img src="http://github-octopress.qiniudn.com/CoreAnimationAdvancedTechnique5.4.png" alt="Mou icon" /></p>

<p>Core Animation提供了一系列的方法用来创建和组合CATransform3D类型的矩阵，和Core Graphics的函数类似，但是3D的平移和旋转多处了一个z参数，并且旋转函数除了angle之外多出了x,y,z三个参数，分别决定了每个坐标轴方向上的旋转：</p>

<pre><code>CATransform3DMakeRotation(CGFloat angle, CGFloat x, CGFloat y, CGFloat z)
CATransform3DMakeScale(CGFloat sx, CGFloat sy, CGFloat sz) 
CATransform3DMakeTranslation(Gloat tx, CGFloat ty, CGFloat tz)
</code></pre>

<p>下图为XYZ轴位置以及相应的旋转</p>

<p><img src="http://github-octopress.qiniudn.com/CoreAnimationAdvancedTechnique5.5.png" alt="Mou icon" /></p>

<p>由图所见，绕Z轴的旋转等同于之前二维空间的仿射旋转，但是绕X轴和Y轴的旋转就突破了屏幕的二维空间，并且在用户视角看来发生了倾斜。</p>

<p><strong>绕Y轴旋转图层</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@implementation ViewController
</span><span class='line'>
</span><span class='line'>- (void)viewDidLoad
</span><span class='line'>{
</span><span class='line'>    [super viewDidLoad];
</span><span class='line'>    //rotate the layer 45 degrees along the Y axis
</span><span class='line'>    CATransform3D transform = CATransform3DMakeRotation(M_PI_4, 0, 1, 0);
</span><span class='line'>    self.layerView.layer.transform = transform;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>@end</span></code></pre></td></tr></table></div></figure>


<p><img src="http://github-octopress.qiniudn.com/CoreAnimationAdvancedTechnique5.6.png" alt="Mou icon" /></p>

<p>看起来图层并没有被旋转，而是仅仅在水平方向上的一个压缩，这是因为我们在用一个斜向的视角看，而不是透视视角。</p>

<h3>5.2.2、透视投影</h3>

<h4>5.2.2.1、透视投影介绍</h4>

<p>在真实世界中，东西离我们越远看起来就越小</p>

<p>在等距投影中，远处的物体和近处的物体保持同样的缩放比例</p>

<p>为了做一些修正，我们需要引入投影变换（又称作z变换）来对除了旋转之外的变换矩阵做一些修改，Core Animation并没有给我们提供设置透视变换的函数，因此我们需要手动修改矩阵值。</p>

<p>CATransform3D的透视效果通过矩阵中m34的值来控制。</p>

<p><strong>m34用于按比例缩放X和Y的值来计算到底要离视角多远。</strong></p>

<p><img src="http://github-octopress.qiniudn.com/CoreAnimationAdvancedTechnique5.7.png" alt="Mou icon" /></p>

<p>m34的默认值是0，我们可以通过设置m34为(-1.0 / d)来应用透视效果，d代表了视角相机和屏幕之间的距离，以像素为单位，那应该如何计算这个距离呢？大概估算一个就行了。</p>

<p>因为视角相机实际上并不存在，所以可以根据屏幕上的显示效果自由决定它放置的位置。通常500-1000就已经很好了，但对于特定的图层有时候更小后者更大的值会看起来更舒服，减少距离的值会增强透视效果，所以一个非常微小的值会让它看起来更加失真，然而一个非常大的值会让它基本失去透视效果。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@implementation ViewController
</span><span class='line'>
</span><span class='line'>- (void)viewDidLoad
</span><span class='line'>{
</span><span class='line'>    [super viewDidLoad];
</span><span class='line'>    // 创建一个新的transform
</span><span class='line'>    CATransform3D transform = CATransform3DIdentity;
</span><span class='line'>    // 应用透视
</span><span class='line'>    transform.m34 = - 1.0 / 500.0;
</span><span class='line'>    // 绕Y轴旋转45度
</span><span class='line'>    transform = CATransform3DRotate(transform, M_PI_4, 0, 1, 0);
</span><span class='line'>    // 应用到图层上
</span><span class='line'>    self.layerView.layer.transform = transform;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>@end</span></code></pre></td></tr></table></div></figure>


<p><img src="http://github-octopress.qiniudn.com/CoreAnimationAdvancedTechnique5.8.png" alt="Mou icon" /></p>

<h4>5.2.2.2、消亡点</h4>

<p>当在透视角度绘图的时候，远离相机视角的物体将会变小变远，当远离到一个极限距离，它们可能就缩成了一个点，于是所有的物体最后都汇聚消失在同一个点。</p>

<p>在现实中，这个点通常是视图的中心，于是为了在应用中创建拟真效果的透视，这个店应该聚在屏幕中点，或者至少是包含所有3D对象的视图中点。</p>

<p>Core Animation定义了这个点位于变换图层的anchorPoint。这就是说，当图层发生变换时，这个点永远位于图层变换之前anchorPoint的位置。</p>

<p>当改变一个图层的position，你也改变了它的消亡点，做3D变换的时候要时刻记住，当你视图通过调整m34来让它更加有3D效果，应该首先把它放置于屏幕中央，然后通过平移来把它移动到指定位置（而不是直接改变它的position），这样所有的3D图层都共享一个消亡点。</p>

<h4>5.2.2.3、sublayerTransform</h4>

<p>如果有多个视图或者图层，每个都要做3D变换，那就需要分别设置相同的m34值，并且确保在变换之前都在屏幕中央共享同一个position。</p>

<p>CALayer有一个属性叫做<code>sublayerTransform</code>。它也是CATransform3D类型，但和对一个图层的变换不同，它影响到所有的子图层。</p>

<p>这意味着你可以一次性对包含这些图层的容器做变换，于是所有的子图层都自动继承了这个变换方法。</p>

<p>通过在一个地方设置透视变换会很方便，同时它会带来另一个显著的优势：</p>

<pre><code>消亡点被设置在容器图层的中点，从而不需要再对子图层分别设置了。

这意味着你可以随意使用position和frame来放置子图层，而不需要把它们放置在屏幕中点，然后为了保证统一的消亡点用变换来做平移。
</code></pre>

<p><strong>小例子：应用sublayerTransform</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@interface ViewController ()
</span><span class='line'>
</span><span class='line'>@property (nonatomic, weak) IBOutlet UIView *containerView;
</span><span class='line'>@property (nonatomic, weak) IBOutlet UIView *layerView1;
</span><span class='line'>@property (nonatomic, weak) IBOutlet UIView *layerView2;
</span><span class='line'>
</span><span class='line'>@end
</span><span class='line'>
</span><span class='line'>@implementation ViewController
</span><span class='line'>
</span><span class='line'>- (void)viewDidLoad
</span><span class='line'>{
</span><span class='line'>    [super viewDidLoad];
</span><span class='line'>    //apply perspective transform to container
</span><span class='line'>    CATransform3D perspective = CATransform3DIdentity;
</span><span class='line'>    perspective.m34 = - 1.0 / 500.0;
</span><span class='line'>    self.containerView.layer.sublayerTransform = perspective;
</span><span class='line'>    //rotate layerView1 by 45 degrees along the Y axis
</span><span class='line'>    CATransform3D transform1 = CATransform3DMakeRotation(M_PI_4, 0, 1, 0);
</span><span class='line'>    self.layerView1.layer.transform = transform1;
</span><span class='line'>    //rotate layerView2 by 45 degrees along the Y axis
</span><span class='line'>    CATransform3D transform2 = CATransform3DMakeRotation(-M_PI_4, 0, 1, 0);
</span><span class='line'>    self.layerView2.layer.transform = transform2;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p><img src="http://github-octopress.qiniudn.com/CoreAnimationAdvancedTechnique5.9.png" alt="Mou icon" /></p>

<h4>5.2.2.4、背面</h4>

<p>既然可以在3D场景下旋转图层，那么旋转180度将会把图层完全旋转一个半圈，于是完全背对了相机视角。</p>

<p>视图的背面，就是一个镜像对称的图片</p>

<p>CALayer有一个叫做<code>doubleSided</code>的属性来控制图层的背面是否要被绘制。这是一个BOOL类型，默认为YES，如果设置为NO，那么当图层正面从相机视角消失的时候，它将不会被绘制。</p>

<h4>5.2.2.5、扁平化图层</h4>

<p>如果对包含已经做过变换的图层的图层做反方向的变换将会发什么什么呢？是不是有点困惑？</p>

<p>如果内部图层相对外部图层做了相反的变换（这里是绕Z轴的旋转），那么按照逻辑这两个变换将被相互抵消。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@interface ViewController ()
</span><span class='line'>
</span><span class='line'>@property (nonatomic, weak) IBOutlet UIView *outerView;
</span><span class='line'>@property (nonatomic, weak) IBOutlet UIView *innerView;
</span><span class='line'>
</span><span class='line'>@end
</span><span class='line'>
</span><span class='line'>@implementation ViewController
</span><span class='line'>
</span><span class='line'>- (void)viewDidLoad
</span><span class='line'>{
</span><span class='line'>    [super viewDidLoad];
</span><span class='line'>    // 外层旋转45度
</span><span class='line'>    CATransform3D outer = CATransform3DMakeRotation(M_PI_4, 0, 0, 1);
</span><span class='line'>    self.outerView.layer.transform = outer;
</span><span class='line'>    // 内层旋转-45度
</span><span class='line'>    CATransform3D inner = CATransform3DMakeRotation(-M_PI_4, 0, 0, 1);
</span><span class='line'>    self.innerView.layer.transform = inner;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>@end</span></code></pre></td></tr></table></div></figure>


<p>代码执行后的样子：</p>

<p><img src="http://github-octopress.qiniudn.com/CoreAnimationAdvancedTechnique5.10.png" alt="Mou icon" /></p>

<p>修改代码，让内外两个视图绕Y轴旋转而不是Z轴，再加上透视效果，以便我们观察。注意不能用sublayerTransform属性，因为内部的图层并不直接是容器图层的子图层，所以这里分别对图层设置透视变换</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)viewDidLoad
</span><span class='line'>{
</span><span class='line'>    [super viewDidLoad];
</span><span class='line'>    //rotate the outer layer 45 degrees
</span><span class='line'>    CATransform3D outer = CATransform3DIdentity;
</span><span class='line'>    outer.m34 = -1.0 / 500.0;
</span><span class='line'>    outer = CATransform3DRotate(outer, M_PI_4, 0, 1, 0);
</span><span class='line'>    self.outerView.layer.transform = outer;
</span><span class='line'>    //rotate the inner layer -45 degrees
</span><span class='line'>    CATransform3D inner = CATransform3DIdentity;
</span><span class='line'>    inner.m34 = -1.0 / 500.0;
</span><span class='line'>    inner = CATransform3DRotate(inner, -M_PI_4, 0, 1, 0);
</span><span class='line'>    self.innerView.layer.transform = inner;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>预期的效果如下</p>

<p><img src="http://github-octopress.qiniudn.com/CoreAnimationAdvancedTechnique5.11.png" alt="Mou icon" /></p>

<p>相反，我们看到的结果如下图所示。</p>

<p><img src="http://github-octopress.qiniudn.com/CoreAnimationAdvancedTechnique5.12.png" alt="Mou icon" /></p>

<p>这是由于Core Animation图层存在于3D空间之内，但它们并不都存在同一个3D空间。每个图层的3D场景其实是扁平化的，当你从正面观察一个图层，看到的实际上由子图层创建的想象出来的3D场景，但当你倾斜这个图层，你会发现实际上这个3D场景仅仅是被绘制在图层的表面。</p>

<p>当你在玩一个3D游戏，实际上仅仅是把屏幕做了一次倾斜，或许在游戏中可以看见有一面墙在你面前，但是倾斜屏幕并不能够看见墙里面的东西。所有场景里面绘制的东西并不会随着你观察它的角度改变而发生变化；图层也是同样的道理。</p>

<p>这使得用Core Animation创建非常复杂的3D场景变得十分困难。</p>

<p>你不能够使用图层树去创建一个3D结构的层级关系&ndash;在相同场景下的任何3D表面必须和同样的图层保持一致，这是因为每个的父视图都把它的子视图扁平化了。</p>

<p>CALayer有一个叫做<code>CATransformLayer</code>的子类来解决这个问题。</p>

<h2>5.3、固体对象</h2>

<h3>5.3.1、创建一个立方体</h3>

<p>现在来试着创建一个固态的3D对象（实际上是一个技术上所谓的空洞对象，但它以固态呈现）。我们用六个独立的视图来构建一个立方体的各个面。</p>

<p><strong>6个View创建一个立方体</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@interface ViewController ()
</span><span class='line'>
</span><span class='line'>@property (nonatomic, weak) IBOutlet UIView *containerView;
</span><span class='line'>@property (nonatomic, strong) IBOutletCollection(UIView) NSArray *faces;
</span><span class='line'>
</span><span class='line'>@end
</span><span class='line'>
</span><span class='line'>@implementation ViewController
</span><span class='line'>
</span><span class='line'>- (void)addFace:(NSInteger)index withTransform:(CATransform3D)transform
</span><span class='line'>{
</span><span class='line'>    // 获取立方体的面并添加到容器上
</span><span class='line'>    UIView *face = self.faces[index];
</span><span class='line'>    [self.containerView addSubview:face];
</span><span class='line'>    // 在容器里居中这些面
</span><span class='line'>    CGSize containerSize = self.containerView.bounds.size;
</span><span class='line'>    face.center = CGPointMake(containerSize.width / 2.0, containerSize.height / 2.0);
</span><span class='line'>    // 应用这些变换
</span><span class='line'>    face.layer.transform = transform;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>- (void)viewDidLoad
</span><span class='line'>{
</span><span class='line'>    [super viewDidLoad];
</span><span class='line'>    // 设置容器子图层的变换
</span><span class='line'>    CATransform3D perspective = CATransform3DIdentity;
</span><span class='line'>    perspective.m34 = -1.0 / 500.0;
</span><span class='line'>    self.containerView.layer.sublayerTransform = perspective;
</span><span class='line'>    // 增加立方体面1
</span><span class='line'>    CATransform3D transform = CATransform3DMakeTranslation(0, 0, 100);
</span><span class='line'>    [self addFace:0 withTransform:transform];
</span><span class='line'>    // 增加立方体面2
</span><span class='line'>    transform = CATransform3DMakeTranslation(100, 0, 0);
</span><span class='line'>    transform = CATransform3DRotate(transform, M_PI_2, 0, 1, 0);
</span><span class='line'>    [self addFace:1 withTransform:transform];
</span><span class='line'>    // 增加立方体面3
</span><span class='line'>    transform = CATransform3DMakeTranslation(0, -100, 0);
</span><span class='line'>    transform = CATransform3DRotate(transform, M_PI_2, 1, 0, 0);
</span><span class='line'>    [self addFace:2 withTransform:transform];
</span><span class='line'>    // 增加立方体面4
</span><span class='line'>    transform = CATransform3DMakeTranslation(0, 100, 0);
</span><span class='line'>    transform = CATransform3DRotate(transform, -M_PI_2, 1, 0, 0);
</span><span class='line'>    [self addFace:3 withTransform:transform];
</span><span class='line'>    // 增加立方体面5
</span><span class='line'>    transform = CATransform3DMakeTranslation(-100, 0, 0);
</span><span class='line'>    transform = CATransform3DRotate(transform, -M_PI_2, 0, 1, 0);
</span><span class='line'>    [self addFace:4 withTransform:transform];
</span><span class='line'>    // 增加立方体面6
</span><span class='line'>    transform = CATransform3DMakeTranslation(0, 0, -100);
</span><span class='line'>    transform = CATransform3DRotate(transform, M_PI, 0, 1, 0);
</span><span class='line'>    [self addFace:5 withTransform:transform];
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>@end</span></code></pre></td></tr></table></div></figure>


<p><img src="http://github-octopress.qiniudn.com/CoreAnimationAdvancedTechnique5.13.png" alt="Mou icon" /></p>

<p>只有一面根本看不出来是立方体</p>

<p>所以我们旋转一下</p>

<p>但是，这个立方体是6个面组成的，正常逻辑就是旋转立方体，这样就必须要旋转6个面</p>

<p>我们还有另外一个简单的方法：调整容器视图的<code>sublayerTransform</code>去旋转照相机</p>

<p>为<code>containerView</code>的layer的<code>perspective</code>增加两行代码</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// 绕X轴旋转45度
</span><span class='line'>perspective = CATransform3DRotate(perspective, -M_PI_4, 1, 0, 0);  
</span><span class='line'>// 绕Y轴旋转45度
</span><span class='line'>perspective = CATransform3DRotate(perspective, -M_PI_4, 0, 1, 0);</span></code></pre></td></tr></table></div></figure>


<p><img src="http://github-octopress.qiniudn.com/CoreAnimationAdvancedTechnique5.14.png" alt="Mou icon" /></p>

<h3>5.3.2、为立方体加上光亮和阴影</h3>

<p>现在它看起来更像是一个立方体了，但是每个面之间的连接处很难分辨，这是因为没有阴影和光照，显得很不真实。</p>

<p>如果想让立方体看起来更加真实，需要自己做一个阴影效果。</p>

<p>可以通过改变每个面的背景颜色或者直接用带光亮效果的图片来调整。</p>

<p>如果要动态创建光线效果，可以根据每个视图的方向应用不同的alpha值做出半透明的阴影图层，但为了计算阴影图层的不透明度，就需要得到每个面垂直于表面的向量，然后根据一个你自己假设的光源来计算出两个向量叉乘结果。</p>

<p>叉乘代表了光源和图层之间的角度，从而决定了它有多大程度上的光亮。</p>

<p><strong>下面的例子用GLKit框架来做向量的计算（你需要引入GLKit库来运行代码），每个面的CATransform3D都被转换成GLKMatrix4，然后通过GLKMatrix4GetMatrix3函数得出一个3×3的旋转矩阵。这个旋转矩阵指定了图层的方向，然后可以用它来得到这个垂直与表面的向量的值。</strong></p>

<p>试着调整<code>LIGHT_DIRECTION</code>和<code>AMBIENT_LIGHT</code>的值来切换光线效果</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#import "ViewController.h" 
</span><span class='line'>#import &lt;QuartzCore/QuartzCore.h&gt; 
</span><span class='line'>#import &lt;GLKit/GLKit.h&gt;
</span><span class='line'>
</span><span class='line'>#define LIGHT_DIRECTION 0, 1, -0.5 
</span><span class='line'>#define AMBIENT_LIGHT 0.5
</span><span class='line'>
</span><span class='line'>@interface ViewController ()
</span><span class='line'>
</span><span class='line'>@property (nonatomic, weak) IBOutlet UIView *containerView;
</span><span class='line'>@property (nonatomic, strong) IBOutletCollection(UIView) NSArray *faces;
</span><span class='line'>
</span><span class='line'>@end
</span><span class='line'>
</span><span class='line'>@implementation ViewController
</span><span class='line'>
</span><span class='line'>- (void)applyLightingToFace:(CALayer *)face
</span><span class='line'>{
</span><span class='line'>    //add lighting layer
</span><span class='line'>    CALayer *layer = [CALayer layer];
</span><span class='line'>    layer.frame = face.bounds;
</span><span class='line'>    [face addSublayer:layer];
</span><span class='line'>    //convert the face transform to matrix
</span><span class='line'>    //(GLKMatrix4 has the same structure as CATransform3D)
</span><span class='line'>    CATransform3D transform = face.transform;
</span><span class='line'>    GLKMatrix4 matrix4 = *(GLKMatrix4 *)&transform;
</span><span class='line'>    GLKMatrix3 matrix3 = GLKMatrix4GetMatrix3(matrix4);
</span><span class='line'>    //get face normal
</span><span class='line'>    GLKVector3 normal = GLKVector3Make(0, 0, 1);
</span><span class='line'>    normal = GLKMatrix3MultiplyVector3(matrix3, normal);
</span><span class='line'>    normal = GLKVector3Normalize(normal);
</span><span class='line'>    //get dot product with light direction
</span><span class='line'>    GLKVector3 light = GLKVector3Normalize(GLKVector3Make(LIGHT_DIRECTION));
</span><span class='line'>    float dotProduct = GLKVector3DotProduct(light, normal);
</span><span class='line'>    //set lighting layer opacity
</span><span class='line'>    CGFloat shadow = 1 + dotProduct - AMBIENT_LIGHT;
</span><span class='line'>    UIColor *color = [UIColor colorWithWhite:0 alpha:shadow];
</span><span class='line'>    layer.backgroundColor = color.CGColor;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>- (void)addFace:(NSInteger)index withTransform:(CATransform3D)transform
</span><span class='line'>{
</span><span class='line'>    //get the face view and add it to the container
</span><span class='line'>    UIView *face = self.faces[index];
</span><span class='line'>    [self.containerView addSubview:face];
</span><span class='line'>    //center the face view within the container
</span><span class='line'>    CGSize containerSize = self.containerView.bounds.size;
</span><span class='line'>    face.center = CGPointMake(containerSize.width / 2.0, containerSize.height / 2.0);
</span><span class='line'>    // apply the transform
</span><span class='line'>    face.layer.transform = transform;
</span><span class='line'>    //apply lighting
</span><span class='line'>    [self applyLightingToFace:face.layer];
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>- (void)viewDidLoad
</span><span class='line'>{
</span><span class='line'>    [super viewDidLoad];
</span><span class='line'>    //set up the container sublayer transform
</span><span class='line'>    CATransform3D perspective = CATransform3DIdentity;
</span><span class='line'>    perspective.m34 = -1.0 / 500.0;
</span><span class='line'>    perspective = CATransform3DRotate(perspective, -M_PI_4, 1, 0, 0);
</span><span class='line'>    perspective = CATransform3DRotate(perspective, -M_PI_4, 0, 1, 0);
</span><span class='line'>    self.containerView.layer.sublayerTransform = perspective;
</span><span class='line'>    //add cube face 1
</span><span class='line'>    CATransform3D transform = CATransform3DMakeTranslation(0, 0, 100);
</span><span class='line'>    [self addFace:0 withTransform:transform];
</span><span class='line'>    //add cube face 2
</span><span class='line'>    transform = CATransform3DMakeTranslation(100, 0, 0);
</span><span class='line'>    transform = CATransform3DRotate(transform, M_PI_2, 0, 1, 0);
</span><span class='line'>    [self addFace:1 withTransform:transform];
</span><span class='line'>    //add cube face 3
</span><span class='line'>    transform = CATransform3DMakeTranslation(0, -100, 0);
</span><span class='line'>    transform = CATransform3DRotate(transform, M_PI_2, 1, 0, 0);
</span><span class='line'>    [self addFace:2 withTransform:transform];
</span><span class='line'>    //add cube face 4
</span><span class='line'>    transform = CATransform3DMakeTranslation(0, 100, 0);
</span><span class='line'>    transform = CATransform3DRotate(transform, -M_PI_2, 1, 0, 0);
</span><span class='line'>    [self addFace:3 withTransform:transform];
</span><span class='line'>    //add cube face 5
</span><span class='line'>    transform = CATransform3DMakeTranslation(-100, 0, 0);
</span><span class='line'>    transform = CATransform3DRotate(transform, -M_PI_2, 0, 1, 0);
</span><span class='line'>    [self addFace:4 withTransform:transform];
</span><span class='line'>    //add cube face 6
</span><span class='line'>    transform = CATransform3DMakeTranslation(0, 0, -100);
</span><span class='line'>    transform = CATransform3DRotate(transform, M_PI, 0, 1, 0);
</span><span class='line'>    [self addFace:5 withTransform:transform];
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>@end</span></code></pre></td></tr></table></div></figure>


<p><img src="http://github-octopress.qiniudn.com/CoreAnimationAdvancedTechnique5.15.png" alt="Mou icon" /></p>

<h3>5.3.3、处理立方体的点击事件</h3>

<p>目前这个立方体点击了没反应，这不是因为响应事件没被处理，而是在于视图的顺序</p>

<p>之前提过，点击事件的处理由视图在父视图中的顺序决定的，而不是3D空间中的Z轴顺序。</p>

<p>当给立方体添加视图的时候，按照视图/图层顺序来说，4，5，6在3的前面。</p>

<p>即使我们看不见4，5，6的表面（因为被1，2，3遮住了），iOS在事件响应上仍然保持之前的顺序。</p>

<p>当试图点击表面3上的按钮，表面4，5，6截断了点击事件（取决于点击的位置），这就和普通的2D布局在按钮上覆盖物体一样。</p>

<p>你也许认为把<code>doubleSided</code>设置成NO可以解决这个问题，因为它不再渲染视图后面的内容，但实际上并不起作用。</p>

<p>因为背对相机而隐藏的视图仍然会响应点击事件（这和通过设置hidden属性或者设置alpha为0而隐藏的视图不同，那两种方式将不会响应事件）。</p>

<p>所以即使禁止了双面渲染仍然不能解决这个问题（虽然由于性能问题，还是需要把它设置成NO）。</p>

<p>但是有几种正确的方案：</p>

<p><strong>1、把除了表面3的其他视图userInteractionEnabled属性都设置成NO来禁止事件传递。</strong></p>

<p><strong>2、简单通过代码把视图3覆盖在视图6上。</strong></p>

<p><img src="http://github-octopress.qiniudn.com/CoreAnimationAdvancedTechnique5.16.png" alt="Mou icon" /></p>

		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2014-07-30T20:30:51+08:00" data-updated="true" itemprop="datePublished"></time></div>
		<div class="tags">


	<a class='category' href='/blog/categories/ios-coreanimation/'>ios-coreanimation</a>


</div>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/2014/07/30/core-animation-advanced-technique-3/" itemprop="url">Core Animation Advanced Technique 学习笔记(3)</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<h1>第一部分：下面的图层</h1>

<h2>4.视觉效果（Visual Effects）</h2>

<h3>4.1、圆角</h3>

<p>CALayer有一个叫做<code>cornerRadius</code>的属性控制着图层角的曲率。</p>

<p>它是一个浮点数，默认为0（即直角，没有圆角）。</p>

<p>默认情况下，这个曲率值只影响该图层的背景颜色而不影响背景图片或是子图层。</p>

<p>不过，如果把masksToBounds设置成YES的话，图层里面的所有东西都会被截取。</p>

<p><strong>举个例子</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>新建两个View,一个View背景色是白色，带有圆角，一个View背景色是红色，中心点在白色View的左上角上，这样会形成什么样的效果？
</span><span class='line'>  
</span><span class='line'>红色View会盖住一部分白色View
</span><span class='line'>
</span><span class='line'>如果此时把白色View的masksToBounds设置为YES,会如何？</span></code></pre></td></tr></table></div></figure>


<p><strong>下图很清晰地展现了结果，左边是masksToBounds设置为NO,右边是masksToBounds设置为YES</strong></p>

<p><img src="http://github-octopress.qiniudn.com/CoreAnimationAdvanced4.1.png" alt="Mou icon" /></p>

<p>当然，单独控制每个层次的圆角也是可以做到的，而且我们经常会用到的上面两个角是圆角，下面两个角是直角的View或者Button的时候，就不能直接用<code>cornerRadius</code>了，而是需要用<code>图层蒙版</code>或者<code>CAShapeLayer</code></p>

<h3>4.2、图层的边框</h3>

<p>CALayer有两个经常用到的属性就是<code>borderWidth</code>和<code>borderColor</code>。这条线（也被称作stroke）沿着图层的bounds绘制（包含图层的角）。</p>

<p><code>borderWidth</code>定义边框粗细,单位为点，浮点型，默认为0。</p>

<p><code>borderColor</code>定义了边框的颜色，默认为黑色。它是CGColorRef类型，而不是UIColor，虽然属性声明并不能证明这一点，但图层引用了borderColor。CGColorRef在引用/释放时候的行为与NSObject极其相似。但是Objective-C语法并不支持这一做法，所以CGColorRef属性即便是强引用也只能声明成assign</p>

<p><strong>边框是绘制在图层边界里面的，而且在所有子内容和子图层之前。</strong></p>

<p><strong>如下图，设置borderWidth = 5.0f</strong></p>

<p><img src="http://github-octopress.qiniudn.com/CoreAnimationAdvanced4.2.png" alt="Mou icon" /></p>

<p>边框并不会把其中包含的图或子图层的形状计算进来，如果图层的子图层超过了边界，或者是内置图在透明区域有一个透明蒙板，边框仍然会沿着图层的边界绘制出来</p>

<p><img src="http://github-octopress.qiniudn.com/CoreAnimationAdvanced4.3.png" alt="Mou icon" /></p>

<h3>4.3、阴影</h3>

<h4>4.3.1阴影介绍</h4>

<p>还有一个常见特性是阴影。阴影可以暗示图层深度。也能用来强调正在显示的图层和优先级，或者只是单纯的装饰。</p>

<p>只要设置<code>shadowOpacity</code>，给一个大于0（0是默认值）的数，就可以显示阴影了，可以显示在任意图层之下。</p>

<p><strong>注：shadowOpacity是一个必须在0.0（不可见）和1.0（完全不透明）之间的浮点数。</strong></p>

<p>如果设置为1.0，将会显示一个有轻微模糊的黑色阴影。要调整阴影还可以使用CALayer的另外三个属性：<code>shadowColor</code>，<code>shadowOffset</code>和<code>shadowRadius</code>。</p>

<p><code>shadowColor</code>控制着阴影的颜色，类型是<code>CGColorRef</code>，默认为黑色</p>

<p><code>shadowOffset</code>控制着阴影的方向和距离。类型是CGSize，width控制这阴影横向的位移，height控制着纵向的位移。默认值是 {0, -3}，即阴影相对于Y轴有3个点的向上位移。</p>

<p><strong>为什么阴影默认向上？</strong></p>

<pre><code>Core Animation是在Mac OS上面世的，而Mac OS和iOS上，二者的Y轴是颠倒的。

这就导致了默认的3个点位移的阴影是向上的。

在Mac上，shadowOffset的默认值是阴影向下的，因此iOS上的阴影方向是向上的了.
</code></pre>

<p>Mac和iOS上的阴影，左侧为iOS的，右侧为Mac的
<img src="http://github-octopress.qiniudn.com/CoreAnimationAdvanced4.4.png" alt="Mou icon" /></p>

<p>苹果更倾向于让用户界面的阴影应该是垂直向下，所以在iOS把阴影宽度设为0，然后高度设为一个正值不失为一个做法。</p>

<p><code>shadowRadius</code>属性控制着阴影的模糊度，当值是0时，阴影就和视图一样有一个非常确定的边界线。当值越来越大的时候，边界线看上去就会越来越模糊和自然。</p>

<p>通常情况，如果想让视图或控件非常醒目（比如弹出框遮罩层），就应该给shadowRadius设置一个稍大的值。阴影越模糊，图层的深度看上去就会更明显，如下图.</p>

<p><img src="http://github-octopress.qiniudn.com/CoreAnimationAdvanced4.5.png" alt="Mou icon" /></p>

<h4>4.3.2、阴影裁剪</h4>

<p>和图层边框不同，图层的阴影继承自内容的外形，而不是根据边界和角半径来确定。</p>

<p>为了计算出阴影的形状，Core Animation会将层中包含的图（包括子视图，如果有的话）考虑在内，然后通过这些来完美搭配图层形状从而创建一个阴影</p>

<p>如图</p>

<p><img src="http://github-octopress.qiniudn.com/CoreAnimationAdvanced4.6.png" alt="Mou icon" /></p>

<p><strong>注：阴影通常就是在Layer的边界之外，于是会出现一些尴尬的效果</strong></p>

<p>如果masksToBounds设为YES，所有从图层中突出来的内容都会被会被剪掉。见下图</p>

<p><img src="http://github-octopress.qiniudn.com/CoreAnimationAdvanced4.7.png" alt="Mou icon" /></p>

<p>阴影被剪掉了，如果想沿着内容裁切，就需要用到两个图层：一个只画阴影的空的外图层，和一个用masksToBounds裁剪内容的内图层。</p>

<p><strong>解决方案是：只把阴影应用在最外层的视图上，而内层视图进行裁剪</strong>，如下图，这次阴影没有被减掉了。</p>

<p><img src="http://github-octopress.qiniudn.com/CoreAnimationAdvanced4.8.png" alt="Mou icon" /></p>

<h4>4.3.3、shadowPath</h4>

<p>已知图层阴影并不总是方的，而是从图层内容的形状继承而来。</p>

<p>但是实时计算阴影也是一个非常消耗资源的，尤其是当图层有多个子图层，而且每个图层还有一个有透明效果的图的时候。（崩溃吧）</p>

<p>如果事先知道阴影形状会是什么样子的，则可以通过指定一个<code>shadowPath</code>来提高性能。</p>

<p><code>shadowPath</code>是CGPathRef类型（一个指向CGPath的指针）。而CGPath是一个Core Graphics对象，用来指定任意的一个矢量图形。我们可以通过这个属性单独于图层形状之外指定阴影的形状。如图：</p>

<p><img src="http://github-octopress.qiniudn.com/CoreAnimationAdvanced4.9.png" alt="Mou icon" /></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@interface ViewController ()
</span><span class='line'>
</span><span class='line'>@property (nonatomic, weak) IBOutlet UIView *layerView1;
</span><span class='line'>@property (nonatomic, weak) IBOutlet UIView *layerView2;
</span><span class='line'>@end
</span><span class='line'>
</span><span class='line'>@implementation ViewController
</span><span class='line'>
</span><span class='line'>- (void)viewDidLoad
</span><span class='line'>{
</span><span class='line'>  [super viewDidLoad];
</span><span class='line'>
</span><span class='line'>  //enable layer shadows
</span><span class='line'>  self.layerView1.layer.shadowOpacity = 0.5f;
</span><span class='line'>  self.layerView2.layer.shadowOpacity = 0.5f;
</span><span class='line'>
</span><span class='line'>  //create a square shadow
</span><span class='line'>  CGMutablePathRef squarePath = CGPathCreateMutable();
</span><span class='line'>  CGPathAddRect(squarePath, NULL, self.layerView1.bounds);
</span><span class='line'>  self.layerView1.layer.shadowPath = squarePath; CGPathRelease(squarePath);
</span><span class='line'>
</span><span class='line'>  ￼//create a circular shadow
</span><span class='line'>  CGMutablePathRef circlePath = CGPathCreateMutable();
</span><span class='line'>  CGPathAddEllipseInRect(circlePath, NULL, self.layerView2.bounds);
</span><span class='line'>  self.layerView2.layer.shadowPath = circlePath; CGPathRelease(circlePath);
</span><span class='line'>}
</span><span class='line'>@end</span></code></pre></td></tr></table></div></figure>


<p><strong>注：如果是规则的图形，用CGPath很不错，如果是复杂形状的图形，则可以使用UIBezierPath更好</strong></p>

<h3>4.4、图层蒙版</h3>

<p>有时候你希望展现的内容不是在一个矩形或圆角矩形。譬如一个有星形框架的图片，又或者想让一些古卷文字慢慢渐变成背景色，而不是一个突兀的边界。</p>

<p>创建一个不规则视图最方便的办法就是<strong>使用一个32位有alpha通道的png图片</strong>，然后给它指定一个透明蒙板。但是这个方法不能让你以编码的方式动态生成蒙板，也不能让子图层或子视图裁剪成同样的形状。</p>

<pre><code>CALayer有一个属性叫做`mask`可以解决这个问题。
</code></pre>

<p><code>mask</code>这个属性是个CALayer类型，有和其他图层一样的绘制和布局属性。类似于一个子图层，相对于父图层（即拥有该属性的图层）布局，但是它却不是一个普通的子图层。不同于那些绘制在父图层中的子图层，mask图层定义了父图层的部分可见区域。</p>

<p>mask图层的颜色完全不重要，只有图层的<code>轮廓</code>最重要。mask属性就像是一个饼干切割机，mask图层实心的部分会被保留下来，其他的则会被抛弃。</p>

<p><img src="http://github-octopress.qiniudn.com/CoreAnimationAdvanced4.10.png" alt="Mou icon" /></p>

<p><strong>如果mask图层比父图层要小，只有在mask图层里面的内容才相关，除此以外的一切都会被隐藏起来</strong>。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@interface ViewController ()
</span><span class='line'>
</span><span class='line'>@property (nonatomic, weak) IBOutlet UIImageView *imageView;
</span><span class='line'>@end
</span><span class='line'>
</span><span class='line'>@implementation ViewController
</span><span class='line'>
</span><span class='line'>- (void)viewDidLoad
</span><span class='line'>{
</span><span class='line'>  [super viewDidLoad];
</span><span class='line'>
</span><span class='line'>  //create mask layer
</span><span class='line'>  CALayer *maskLayer = [CALayer layer];
</span><span class='line'>  maskLayer.frame = self.layerView.bounds;
</span><span class='line'>  UIImage *maskImage = [UIImage imageNamed:@"Cone.png"];
</span><span class='line'>  maskLayer.contents = (__bridge id)maskImage.CGImage;
</span><span class='line'>
</span><span class='line'>  //apply mask to image layer￼
</span><span class='line'>  self.imageView.layer.mask = maskLayer;
</span><span class='line'>}
</span><span class='line'>@end</span></code></pre></td></tr></table></div></figure>


<p>设置好蒙版之后，效果如下</p>

<p><img src="http://github-octopress.qiniudn.com/CoreAnimationAdvanced4.11.png" alt="Mou icon" /></p>

<p><strong>注：任何有图层的都可以作为蒙版，因此可以用代码甚至动画来生成，还是非常方便的</strong></p>

<h3>4.5、缩放过滤</h3>

<h4>4.5.1、三种过滤算法</h4>

<p>当视图显示一个图片的时候，都应该以正确的比例和正确的1：1像素显示在屏幕上。原因如下：</p>

<ul>
<li><p>能够显示最好的画质，像素既没有被压缩也没有被拉伸。</p></li>
<li><p>能更好的使用内存。</p></li>
<li><p>最好的性能表现，CPU不需要为此额外的计算。</p></li>
<li><p>有时候，显示一个非真实大小的图片确实是我们需要的效果。比如说一个头像或是图片的缩略图，再比如说一个可以被拖拽和伸缩的大图。这些情况下，为同一图片的不同大小存储不同的图片显得又不切实际。</p></li>
</ul>


<p>当图片需要显示不同的大小的时候，有一种叫做<code>缩放过滤</code>的算法就起到作用了。<strong>它作用于原图的像素上并根据需要生成新的像素并显示在屏幕上</strong>。</p>

<p><strong>CALayer为此提供了三种缩放过滤的方式</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>kCAFilterLinear
</span><span class='line'>kCAFilterNearest
</span><span class='line'>kCAFilterTrilinear</span></code></pre></td></tr></table></div></figure>


<p><code>minification</code>（缩小图片）和<code>magnification</code>（放大图片）默认的过滤器都是<code>kCAFilterLinear</code>，这个过滤器采用<code>双线性滤波算法</code>，它在大多数情况下都表现良好。</p>

<p><code>双线性滤波算法</code>通过对多个像素取样最终生成新的值，得到一个平滑的表现不错的拉伸。</p>

<p><strong>但是当放大倍数比较大的时候图片就模糊不清了。</strong></p>

<p><code>kCAFilterTrilinear</code>和<code>kCAFilterLinear</code>非常相似，大部分情况下二者都看不出来有什么差别。</p>

<p>但是，较双线性滤波算法而言，<code>三线性滤波算法</code>存储了多个大小情况下的图片（也叫多重贴图），并三维取样，同时结合大图和小图的存储进而得到最后的结果。</p>

<p>这使得算法能够从一系列已经接近于最终大小的图片中得到想要的结果，换言之不需要对很多像素同步取样。这不仅提高了性能，也避免了因舍入错误引起的取样失灵的小概率问题</p>

<p><code>kCAFilterNearest</code>是一种比较武断的方法。这个算法（也叫最近过滤）就是取样最近的单像素点而不管其他的颜色。这样做非常快，也不会使图片模糊。但是，最明显的效果就是，会使得压缩图片更糟，图片放大之后也显得块状或是马赛克严重。</p>

<p>下图是双线性滤波和三线性滤波与最近过滤算法之间的对比，主要对大图</p>

<p><img src="http://github-octopress.qiniudn.com/CoreAnimationAdvanced4.12.png" alt="Mou icon" /></p>

<p>下图是没有斜线的小图，使用三种过滤算法的结果</p>

<p><img src="http://github-octopress.qiniudn.com/CoreAnimationAdvanced4.13.png" alt="Mou icon" /></p>

<p>总的来说，对于比较小的图或者是差异特别明显，极少斜线的大图，最近过滤算法会保留这种差异明显的特质以呈现更好的结果。但是对于大多数的图尤其是有很多斜线或是曲线轮廓的图片来说，最近过滤算法会导致更差的结果。换句话说，<strong>线性过滤保留了形状，最近过滤则保留了像素的差异</strong>。</p>

<h4>4.5.2、小例子</h4>

<p>我们用简单的像素字体创造数字显示方式，用图片存储起来，而且用之前介绍过的拼合技术来显示</p>

<p><img src="http://github-octopress.qiniudn.com/CoreAnimationAdvanced4.14.png" alt="Mou icon" /></p>

<p>我们在Interface Builder中放置了六个视图，小时、分钟、秒钟各两个.用了一个IBOutletCollection对象把他们和控制器联系起来，这样就可以以数组的方式访问视图了，下图是代码，IB上放置控件是从左到右依次排列的。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@interface ViewController ()
</span><span class='line'>
</span><span class='line'>@property (nonatomic, strong) IBOutletCollection(UIView) NSArray *digitViews;
</span><span class='line'>@property (nonatomic, weak) NSTimer *timer;
</span><span class='line'>￼￼
</span><span class='line'>@end
</span><span class='line'>
</span><span class='line'>@implementation ViewController
</span><span class='line'>
</span><span class='line'>- (void)viewDidLoad
</span><span class='line'>{
</span><span class='line'>  [super viewDidLoad]; //get spritesheet image
</span><span class='line'>  UIImage *digits = [UIImage imageNamed:@"Digits.png"];
</span><span class='line'>
</span><span class='line'>  //set up digit views
</span><span class='line'>  for (UIView *view in self.digitViews) {
</span><span class='line'>    //set contents
</span><span class='line'>    view.layer.contents = (__bridge id)digits.CGImage;
</span><span class='line'>    view.layer.contentsRect = CGRectMake(0, 0, 0.1, 1.0);
</span><span class='line'>    view.layer.contentsGravity = kCAGravityResizeAspect;
</span><span class='line'>  }
</span><span class='line'>
</span><span class='line'>  //start timer
</span><span class='line'>  self.timer = [NSTimer scheduledTimerWithTimeInterval:1.0 target:self selector:@selector(tick) userInfo:nil repeats:YES];
</span><span class='line'>
</span><span class='line'>  //set initial clock time
</span><span class='line'>  [self tick];
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>- (void)setDigit:(NSInteger)digit forView:(UIView *)view
</span><span class='line'>{
</span><span class='line'>  //adjust contentsRect to select correct digit
</span><span class='line'>  view.layer.contentsRect = CGRectMake(digit * 0.1, 0, 0.1, 1.0);
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>- (void)tick
</span><span class='line'>{
</span><span class='line'>  //convert time to hours, minutes and seconds
</span><span class='line'>  NSCalendar *calendar = [[NSCalendar alloc] initWithCalendarIdentifier: NSGregorianCalendar];
</span><span class='line'>  NSUInteger units = NSHourCalendarUnit | NSMinuteCalendarUnit | NSSecondCalendarUnit;
</span><span class='line'>  ￼
</span><span class='line'>  NSDateComponents *components = [calendar components:units fromDate:[NSDate date]];
</span><span class='line'>
</span><span class='line'>  //set hours
</span><span class='line'>  [self setDigit:components.hour / 10 forView:self.digitViews[0]];
</span><span class='line'>  [self setDigit:components.hour % 10 forView:self.digitViews[1]];
</span><span class='line'>
</span><span class='line'>  //set minutes
</span><span class='line'>  [self setDigit:components.minute / 10 forView:self.digitViews[2]];
</span><span class='line'>  [self setDigit:components.minute % 10 forView:self.digitViews[3]];
</span><span class='line'>
</span><span class='line'>  //set seconds
</span><span class='line'>  [self setDigit:components.second / 10 forView:self.digitViews[4]];
</span><span class='line'>  [self setDigit:components.second % 10 forView:self.digitViews[5]];
</span><span class='line'>}
</span><span class='line'>@end</span></code></pre></td></tr></table></div></figure>


<p>结果如下：</p>

<p><img src="http://github-octopress.qiniudn.com/CoreAnimationAdvanced4.15.png" alt="Mou icon" /></p>

<p>因为默认是<code>kCAFilterLinear</code>，所以导致缩放图片时图片模糊了，在<code>for循环</code>中加入</p>

<pre><code>view.layer.magnificationFilter = kCAFilterNearest;
</code></pre>

<p>效果如下</p>

<p><img src="http://github-octopress.qiniudn.com/CoreAnimationAdvanced4.16.png" alt="Mou icon" /></p>

<h3>4.6成组透明</h3>

<p>UIView有一个<code>alpha</code>的属性来确定视图的<code>透明度</code>。CALayer有一个等同的属性叫做<code>opacity</code>，这两个属性都是影响子层级的。</p>

<p><strong>换言之，如果给一个图层设置了opacity属性，那它的子图层都会受此影响。</strong></p>

<p>iOS里经常会把控件的alpha值设置成0.5，即50%的不透明度，这样看起来仿佛是控件处于不可用的状态，但是当一个控件有子视图的时候就有点奇怪了</p>

<p>下图是一个内嵌了UILabel的自定义UIButton；左边是一个不透明的按钮，右边是50%透明度的相同按钮。</p>

<p><img src="http://github-octopress.qiniudn.com/CoreAnimationAdvanced4.17.png" alt="Mou icon" /></p>

<p>这个问题由透明度的混合叠加导致，当显示一个50%透明度的图层时，图层的每个像素都会一半显示图层的颜色，另一半显示图层下面的颜色。</p>

<p>但是如果图层包含一个同样显示50%透明的子图层时，你所看到的视图，50%来自子视图，25%来了图层本身的颜色，另外的25%则来自背景色。</p>

<p>在刚才的例子中，Button和Label都是白色背景。而且都是50%的可见度，于是叠加起来导致透明度度是75%，所以Label所在的区域看上去就没有周围的部分那么透明。</p>

<p>理想状况下，当你设置了一个图层的透明度，你希望它包含的整个图层树像一个整体一样的透明效果。</p>

<p><strong>方法一：你可以把Info.plist文件中的UIViewGroupOpacity设置为YES来达到这个效果</strong></p>

<p><strong>但是这个设置会影响到这个应用，整个app可能会受到不良影响。</strong></p>

<pre><code>如果UIViewGroupOpacity并未设置，iOS 6和以前的版本会默认为NO（也许以后的版本会有一些改变，还没研究ios7的效果如何）。
</code></pre>

<p><strong>方法二，可以设置CALayer的一个叫做shouldRasterize属性来实现组透明的效果</strong></p>

<p>如果它被设置为YES，在应用透明度之前，图层及其子图层都会被整合成一个整体的图片，这样就没有透明度混合的问题了</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@interface ViewController ()
</span><span class='line'>@property (nonatomic, weak) IBOutlet UIView *containerView;
</span><span class='line'>@end
</span><span class='line'>
</span><span class='line'>@implementation ViewController
</span><span class='line'>
</span><span class='line'>- (UIButton *)customButton
</span><span class='line'>{
</span><span class='line'>  //create button
</span><span class='line'>  CGRect frame = CGRectMake(0, 0, 150, 50);
</span><span class='line'>  UIButton *button = [[UIButton alloc] initWithFrame:frame];
</span><span class='line'>  button.backgroundColor = [UIColor whiteColor];
</span><span class='line'>  button.layer.cornerRadius = 10;
</span><span class='line'>
</span><span class='line'>  //add label
</span><span class='line'>  frame = CGRectMake(20, 10, 110, 30);
</span><span class='line'>  UILabel *label = [[UILabel alloc] initWithFrame:frame];
</span><span class='line'>  label.text = @"Hello World";
</span><span class='line'>  label.textAlignment = NSTextAlignmentCenter;
</span><span class='line'>  [button addSubview:label];
</span><span class='line'>  return button;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>- (void)viewDidLoad
</span><span class='line'>{
</span><span class='line'>  [super viewDidLoad];
</span><span class='line'>
</span><span class='line'>  //create opaque button
</span><span class='line'>  UIButton *button1 = [self customButton];
</span><span class='line'>  button1.center = CGPointMake(50, 150);
</span><span class='line'>  [self.containerView addSubview:button1];
</span><span class='line'>
</span><span class='line'>  //create translucent button
</span><span class='line'>  UIButton *button2 = [self customButton];
</span><span class='line'>  ￼
</span><span class='line'>  button2.center = CGPointMake(250, 150);
</span><span class='line'>  button2.alpha = 0.5;
</span><span class='line'>  [self.containerView addSubview:button2];
</span><span class='line'>
</span><span class='line'>  //enable rasterization for the translucent button
</span><span class='line'>  button2.layer.shouldRasterize = YES;
</span><span class='line'>  button2.layer.rasterizationScale = [UIScreen mainScreen].scale;
</span><span class='line'>}
</span><span class='line'>@end</span></code></pre></td></tr></table></div></figure>


<p>为了打开<code>shouldRasterize</code>属性，要设置了图层的<code>rasterizationScale</code>属性。默认情况下，所有图层拉伸都是1.0， <strong>所以如果你使用了<code>shouldRasterize</code>属性，你就要确保你设置了<code>rasterizationScale</code>属性去匹配屏幕，以防止出现Retina屏幕像素化的问题</strong>。</p>

<p><strong>注：当shouldRasterize和UIViewGroupOpacity一起设置的时候，会出现性能问题</strong></p>

<p>下图是设置了shouldRasterize的效果</p>

<p><img src="http://github-octopress.qiniudn.com/CoreAnimationAdvanced4.18.png" alt="Mou icon" /></p>

		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2014-07-26T22:28:44+08:00" data-updated="true" itemprop="datePublished"></time></div>
		<div class="tags">


	<a class='category' href='/blog/categories/ios-coreanimation/'>ios-coreanimation</a>


</div>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/2014/07/26/core-animation-advanced-technique-2/" itemprop="url">Core Animation Advanced Technique 学习笔记(2)</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<h1>第一部分：下面的图层</h1>

<h2>3、图层几何学(Layer Geometry)</h2>

<h3>3.1、布局属性</h3>

<p>UIView有三个比较重要的布局属性：<code>frame</code>，<code>bounds</code>和<code>center</code>，这三者在CALayer中分别对应地<code>frame</code>，<code>bounds</code>和<code>position</code>。为了能清楚区分，图层用了“position”，视图用了“center”，但是他们都代表同样的值。</p>

<p>frame代表了图层的外部坐标（也就是在父图层上占据的空间）</p>

<p>bounds是内部坐标（{0, 0}通常是图层的左上角）</p>

<p>center和position都代表了相对于父图层anchorPoint所在的位置。</p>

<p>anchorPoint的属性将会在后续介绍到，现在把它想成图层的中心点就好了。</p>

<p>下图显示了这些属性是如何相互依赖的。</p>

<p><img src="http://github-octopress.qiniudn.com/CoreAnimationAdvanced3.1.jpeg" alt="Mou icon" /></p>

<h3>3.2、View和Layer的frame/bounds/center之间的关系</h3>

<p>View的frame，bounds和center属性仅仅是存取方法，改变View的frame，实际上是在改变位于View下方CALayer的frame，不能够独立于Layer之外改变View的frame。</p>

<p>其实，frame其实是一个虚拟属性，是根据bounds，position和transform计算而来，所以当其中任何一个值发生改变，frame都会变化。相反，改变frame的值同样会影响到他们当中的值</p>

<p>当对Layer做变换的时候，比如旋转或者缩放，frame实际上代表了覆盖在Layer旋转之后的整个轴对齐的矩形区域，也就是说frame的宽高可能和bounds的宽高不再一致了</p>

<p><strong>注意下图的frame 和 bounds，这是旋转之后的View和Layer的属性情况</strong>
<img src="http://github-octopress.qiniudn.com/CoreAnimationAdvanced3.2.jpeg" alt="Mou icon" /></p>

<h3>3.3、锚点（anchorPoint）</h3>

<p>View的center属性和Layer的position属性都指定了相对于父图层anchorPoint的位置。</p>

<p>图层的anchorPoint通过position来控制它的frame的位置。</p>

<p>默认来说，anchorPoint位于图层的中点，所以图层的将会以这个点为中心放置。</p>

<p>anchorPoint属性并没有被UIView接口暴露出来，这也是视图的position属性被叫做“center”的原因。</p>

<p>但是图层的anchorPoint可以被移动，比如你可以把它置于图层frame的左上角，于是图层的内容将会向右下角的position方向移动，而不是居中了。</p>

<p><img src="http://github-octopress.qiniudn.com/CoreAnimationAdvanced3.3.jpeg" alt="Mou icon" /></p>

<p>和contentsRect / contentsCenter属性类似，<code>anchorPoint</code>用<code>单位坐标</code>来描述，也就是图层的相对坐标，图层左上角是{0, 0}，右下角是{1, 1}，因此默认坐标是{0.5, 0.5}。anchorPoint可以通过指定x和y值小于0或者大于1，使它放置在图层范围之外。</p>

<p>上图中，当改变了anchorPoint，position属性保持固定的值并没有发生改变，但是frame却移动了。</p>

<h4>3.3.1、什么场合需要用到锚点？</h4>

<p>举例说明，创建一个模拟闹钟的项目。</p>

<p>钟面和钟表由四张图片组成（图3.4），为了简单说明，我们还是用传统的方式来装载和加载图片，使用四个UIImageView实例（当然你也可以用正常的视图，设置他们图层的<code>contents</code>图片）。</p>

<p><img src="http://github-octopress.qiniudn.com/CoreAnimationAdvanced3.4.jpeg" alt="Mou icon" /></p>

<p>闹钟的组件通过IB来排列，这些图片视图嵌套在一个容器视图之内，并且自动调整和自动布局都被禁用了。这是因为自动调整会影响到视图的frame，当视图旋转的时候，frame是会发生改变的，这将会导致一些布局上的失灵。</p>

<p>我们用NSTimer来更新闹钟，使用视图的transform属性来旋转钟表</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@interface ViewController ()
</span><span class='line'>
</span><span class='line'>@property (nonatomic, weak) IBOutlet UIImageView *hourHand;
</span><span class='line'>@property (nonatomic, weak) IBOutlet UIImageView *minuteHand;
</span><span class='line'>@property (nonatomic, weak) IBOutlet UIImageView *secondHand;
</span><span class='line'>@property (nonatomic, weak) NSTimer *timer;
</span><span class='line'>
</span><span class='line'>@end
</span><span class='line'>
</span><span class='line'>@implementation ViewController
</span><span class='line'>
</span><span class='line'>- (void)viewDidLoad
</span><span class='line'>{
</span><span class='line'>    [super viewDidLoad];
</span><span class='line'>    //start timer
</span><span class='line'>    self.timer = [NSTimer scheduledTimerWithTimeInterval:1.0 target:self selector:@selector(tick) userInfo:nil repeats:YES];
</span><span class='line'>                  ￼
</span><span class='line'>    //set initial hand positions
</span><span class='line'>    [self tick];
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>- (void)tick
</span><span class='line'>{
</span><span class='line'>    //convert time to hours, minutes and seconds
</span><span class='line'>    NSCalendar *calendar = [[NSCalendar alloc] initWithCalendarIdentifier:NSGregorianCalendar];
</span><span class='line'>    NSUInteger units = NSHourCalendarUnit | NSMinuteCalendarUnit | NSSecondCalendarUnit;
</span><span class='line'>    NSDateComponents *components = [calendar components:units fromDate:[NSDate date]];
</span><span class='line'>    CGFloat hoursAngle = (components.hour / 12.0) * M_PI * 2.0;
</span><span class='line'>    //calculate hour hand angle //calculate minute hand angle
</span><span class='line'>    CGFloat minsAngle = (components.minute / 60.0) * M_PI * 2.0;
</span><span class='line'>    //calculate second hand angle
</span><span class='line'>    CGFloat secsAngle = (components.second / 60.0) * M_PI * 2.0;
</span><span class='line'>    //rotate hands
</span><span class='line'>    self.hourHand.transform = CGAffineTransformMakeRotation(hoursAngle);
</span><span class='line'>    self.minuteHand.transform = CGAffineTransformMakeRotation(minsAngle);
</span><span class='line'>    self.secondHand.transform = CGAffineTransformMakeRotation(secsAngle);
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>@end
</span></code></pre></td></tr></table></div></figure>


<p>结果如下</p>

<p><img src="http://github-octopress.qiniudn.com/CoreAnimationAdvanced3.5.jpeg" alt="Mou icon" /></p>

<p>你也许会认为可以在Interface Builder当中调整指针图片的位置来解决，但其实并不能达到目的，因为如果不放在钟面中间的话，同样不能正确的旋转。</p>

<p>也许在图片末尾添加一个透明空间也是个解决方案，但这样会让图片变大，也会消耗更多的内存，这样并不优雅。</p>

<p>更好的方案是使用anchorPoint属性，我们来在-viewDidLoad方法中添加几行代码来给每个钟指针的anchorPoint做一些平移</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)viewDidLoad 
</span><span class='line'>{
</span><span class='line'>    [super viewDidLoad];
</span><span class='line'>    // adjust anchor points
</span><span class='line'>
</span><span class='line'>    self.secondHand.layer.anchorPoint = CGPointMake(0.5f, 0.9f); 
</span><span class='line'>    self.minuteHand.layer.anchorPoint = CGPointMake(0.5f, 0.9f); 
</span><span class='line'>    self.hourHand.layer.anchorPoint = CGPointMake(0.5f, 0.9f);
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>    // start timer
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>结果如下</p>

<p><img src="http://github-octopress.qiniudn.com/CoreAnimationAdvanced3.6.jpeg" alt="Mou icon" /></p>

<h3>3.4、坐标系</h3>

<p>和视图一样，图层在图层树当中也是相对于父图层按层级关系放置，一个图层的position依赖于它父图层的bounds，如果父图层发生了移动，它的所有子图层也会跟着移动。</p>

<p>这样你可以通过移动根图层来将它的子图层作为一个整体来移动，但是有时候你需要知道一个图层的绝对位置，或者是相对于另一个图层的位置，而不是它当前父图层的位置。</p>

<p>CALayer给不同坐标系之间的图层转换提供了一些工具类方法：</p>

<ul>
<li>(CGPoint)convertPoint:(CGPoint)point fromLayer:(CALayer *)layer;</li>
<li>(CGPoint)convertPoint:(CGPoint)point toLayer:(CALayer *)layer;</li>
<li>(CGRect)convertRect:(CGRect)rect fromLayer:(CALayer *)layer;</li>
<li>(CGRect)convertRect:(CGRect)rect toLayer:(CALayer *)layer;</li>
</ul>


<p>这些方法可以把定义在一个图层坐标系下的点或者矩形转换成另一个图层坐标系下的点或者矩形</p>

<h3>3.5、翻转的几何结构</h3>

<p>常规说来，在iOS上，一个图层的position位于父图层的左上角，但是在Mac OS上，通常是位于左下角。</p>

<p>Core Animation可以通过<code>geometryFlipped</code>属性来适配这两种情况，它决定了一个图层的坐标是否相对于父图层垂直翻转，是一个BOOL类型。</p>

<p>在iOS上通过设置它为YES意味着它的子图层将会被垂直翻转，也就是将会沿着底部排版而不是通常的顶部（它的所有子图层也同理，除非把它们的geometryFlipped属性也设为YES）。</p>

<h4>3.5.1、Z坐标轴</h4>

<p>和UIView严格的二维坐标系不同，CALayer存在于一个三维空间当中。</p>

<p>除了我们已经讨论过的position和anchorPoint属性之外，CALayer还有另外两个属性，<code>zPosition</code>和<code>anchorPointZ</code>，二者都是在Z轴上描述图层位置的浮点类型。</p>

<p>注意这里并没有更深的属性来描述由宽和高做成的bounds了，图层是一个完全扁平的对象，你可以把它们想象成类似于一页二维的坚硬的纸片，用胶水粘成一个空洞，就像三维结构的折纸一样。</p>

<p>zPosition属性在大多数情况下其实并不常用。</p>

<p><strong>除了做变换之外，zPosition最实用的功能就是改变图层的显示顺序了。</strong></p>

<p>通常，图层是根据它们子图层的sublayers出现的顺序来类绘制的，但是通过增加图层的zPosition，就可以把图层前置，于是它就在所有其他图层的前面了（或者至少是小于它的zPosition值的图层的前面）。</p>

<p>两个视图，绿色视图在红色后面，显示被红色遮住了一部分。</p>

<p><strong>如果我们提高绿色视图的zPosition</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)viewDidLoad
</span><span class='line'>{
</span><span class='line'>    [super viewDidLoad];
</span><span class='line'>    ￼
</span><span class='line'>    //move the green view zPosition nearer to the camera
</span><span class='line'>    self.greenView.layer.zPosition = 1.0f;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>我们会发现红色在绿色后面了。其实并不需要增加太多，视图都非常地薄，给zPosition提高一个像素就可以让绿色视图前置，当然0.1或者0.0001也能够做到，但是最好不要这样，<code>因为浮点类型四舍五入的计算可能会造成一些不便的麻烦</code>。</p>

<h3>3.6、Layer处理事件</h3>

<p>CALayer并不关心任何响应链事件，所以不能直接处理触摸事件或者手势。</p>

<p>但是它有一系列的方法帮你处理事件：<code>-containsPoint:</code>和<code>-hitTest:</code>。</p>

<h4>3.6.1、containsPoint</h4>

<p>-containsPoint:接受一个在本图层坐标系下的CGPoint，如果这个点在图层frame范围内就返回YES。但是这需要把触摸坐标转换成每个图层坐标系下的坐标，结果很不方便。</p>

<p>下面是使用containsPoint判断被点击的图层</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)viewDidLoad
</span><span class='line'>{
</span><span class='line'>    [super viewDidLoad];
</span><span class='line'>    //create sublayer
</span><span class='line'>    self.blueLayer = [CALayer layer];
</span><span class='line'>    self.blueLayer.frame = CGRectMake(50.0f, 50.0f, 100.0f, 100.0f);
</span><span class='line'>    self.blueLayer.backgroundColor = [UIColor blueColor].CGColor;
</span><span class='line'>    //add it to our view
</span><span class='line'>    [self.layerView.layer addSublayer:self.blueLayer];
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event
</span><span class='line'>{
</span><span class='line'>    //get touch position relative to main view
</span><span class='line'>    CGPoint point = [[touches anyObject] locationInView:self.view];
</span><span class='line'>    //convert point to the white layer's coordinates
</span><span class='line'>    point = [self.layerView.layer convertPoint:point fromLayer:self.view.layer];
</span><span class='line'>    //get layer using containsPoint:
</span><span class='line'>    if ([self.layerView.layer containsPoint:point]) {
</span><span class='line'>        //convert point to blueLayer’s coordinates
</span><span class='line'>        point = [self.blueLayer convertPoint:point fromLayer:self.layerView.layer];
</span><span class='line'>        if ([self.blueLayer containsPoint:point]) {
</span><span class='line'>            [[[UIAlertView alloc] initWithTitle:@"Inside Blue Layer" 
</span><span class='line'>                                        message:nil
</span><span class='line'>                                       delegate:nil 
</span><span class='line'>                              cancelButtonTitle:@"OK"
</span><span class='line'>                              otherButtonTitles:nil] show];
</span><span class='line'>        } else {
</span><span class='line'>            [[[UIAlertView alloc] initWithTitle:@"Inside White Layer"
</span><span class='line'>                                        message:nil 
</span><span class='line'>                                       delegate:nil
</span><span class='line'>                              cancelButtonTitle:@"OK"
</span><span class='line'>                              otherButtonTitles:nil] show];
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h4>3.6.2、hitTest</h4>

<p>-hitTest:方法同样接受一个CGPoint类型参数，而不是BOOL类型，它返回图层本身，或者包含这个坐标点的叶子节点图层。这意味着不再需要像使用-containsPoint:那样，人工地在每个子图层变换或者测试点击的坐标。如果这个点在最外面图层的范围之外，则返回nil。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event
</span><span class='line'>{
</span><span class='line'>    //get touch position
</span><span class='line'>    CGPoint point = [[touches anyObject] locationInView:self.view];
</span><span class='line'>    //get touched layer
</span><span class='line'>    CALayer *layer = [self.layerView.layer hitTest:point];
</span><span class='line'>    //get layer using hitTest
</span><span class='line'>    if (layer == self.blueLayer) {
</span><span class='line'>        [[[UIAlertView alloc] initWithTitle:@"Inside Blue Layer"
</span><span class='line'>                                    message:nil
</span><span class='line'>                                   delegate:nil
</span><span class='line'>                          cancelButtonTitle:@"OK"
</span><span class='line'>                          otherButtonTitles:nil] show];
</span><span class='line'>    } else if (layer == self.layerView.layer) {
</span><span class='line'>        [[[UIAlertView alloc] initWithTitle:@"Inside White Layer"
</span><span class='line'>                                    message:nil
</span><span class='line'>                                   delegate:nil
</span><span class='line'>                          cancelButtonTitle:@"OK"
</span><span class='line'>                          otherButtonTitles:nil] show];
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>注意当调用图层的-hitTest:方法时，测算的顺序严格依赖于图层树当中的图层顺序（和UIView处理事件类似）。zPosition属性可以明显改变屏幕上图层的顺序，但不能改变事件传递的顺序。</p>

<p>这意味着如果改变了图层的z轴顺序，你会发现将不能够检测到最前方的视图点击事件，这是因为被另一个图层遮盖住了，虽然它的zPosition值较小，但是在图层树中的顺序靠前。</p>

<h3>3.7、自动布局</h3>

<p>你可能用过<code>UIViewAutoresizingMask</code>类型的一些常量，应用于当父视图改变尺寸的时候，相应UIView的frame也跟着更新的场景（通常用于横竖屏切换）。</p>

<p>在iOS6中，苹果介绍了自动排版机制，它和自动调整不同，并且更加复杂。</p>

<p>在Mac OS平台，CALayer有一个叫做layoutManager的属性可以通过CALayoutManager协议和CAConstraintLayoutManager类来实现自动排版的机制。但由于某些原因，这在iOS上并不适用。</p>

<p>当使用视图的时候，可以充分利用UIView类接口暴露出来的UIViewAutoresizingMask和NSLayoutConstraintAPI，但如果想随意控制CALayer的布局，就需要手工操作。</p>

<p>最简单的方法就是使用CALayerDelegate如下函数：</p>

<pre><code>- (void)layoutSublayersOfLayer:(CALayer *)layer;
</code></pre>

<p>当图层的bounds发生改变，或者图层的-setNeedsLayout方法被调用的时候，这个函数将会被执行。</p>

<p>这使得你可以手动地重新摆放或者重新调整子图层的大小，但是不能像UIView的autoresizingMask和constraints属性做到自适应屏幕旋转。</p>

<p>这也是为什么最好使用视图而不是单独的图层来构建应用程序的另一个重要原因之一。</p>

		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2014-07-26T17:00:01+08:00" data-updated="true" itemprop="datePublished"></time></div>
		<div class="tags">


	<a class='category' href='/blog/categories/ios-coreanimation/'>ios-coreanimation</a>


</div>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/2014/07/26/core-animation-advanced-technique-1/" itemprop="url">Core Animation Advanced Techniques 学习笔记(1)</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<h1>第一部分：下面的图层</h1>

<h2>1、图层树(The Layer Tree)</h2>

<h3>图层介绍</h3>

<p>在iOS当中，所有的视图都从一个叫做UIVIew的基类派生而来，UIView可以处理触摸事件，可以支持基于Core Graphics绘图，可以做仿射变换（例如旋转或者缩放），或者简单的类似于滑动或者渐变的动画。</p>

<p>和UIView最大的不同是CALayer不处理用户的交互。CALayer并不清楚具体的响应链（iOS通过视图层级关系用来传送触摸事件的机制），于是它并不能够响应事件，即使它提供了一些方法来判断是否一个触点在图层的范围之内</p>

<p>每一个UIView都有一个CALayer实例的图层属性，也就是所谓的backing layer，视图的职责就是创建并管理这个图层，以确保当子视图在层级关系中添加或者被移除的时候，他们关联的图层也同样对应在层级关系树当中有相同的操作</p>

<p>实际上这些背后关联的图层才是真正用来在屏幕上显示和做动画，UIView仅仅是对它的一个封装，提供了一些iOS类似于处理触摸的具体功能，以及Core Animation底层方法的高级接口。</p>

<p>但是为什么iOS要基于UIView和CALayer提供两个平行的层级关系呢？原因在于要做职责分离，这样也能避免很多重复代码。在iOS和Mac OS两个平台上，事件和用户交互有很多地方的不同，基于多点触控的用户界面和基于鼠标键盘有着本质的区别</p>

<p>这里有一些UIView没有暴露出来的CALayer的功能：</p>

<ul>
<li>阴影，圆角，带颜色的边框</li>
<li>3D变换</li>
<li>非矩形范围</li>
<li>透明遮罩</li>
<li>多级非线性动画</li>
</ul>


<h3>小例子：增加蓝色子图层</h3>

<pre><code>CALayer *blueLayer = [CALayer layer];
blueLayer.frame = CGRectMake(50.0f, 50.0f, 100.0f, 100.0f);
blueLayer.backgroundColor = [UIColor blueColor].CGColor;
//把layer加到view上
[self.layerView.layer addSublayer:blueLayer];
</code></pre>

<h3>为什么要使用Layer</h3>

<p>一个UIView只有一个相关联的CALayer（自动创建），同时它也可以支持添加无数多个子CALayer，你可以显示创建一个单独的Layer，并且把它直接添加到视图关联图层的子Layer。尽管可以这样添加Layer，但往往我们只是见简单地处理View，他们关联的Layer并不需要额外地手动添加子Layer。</p>

<p>在Mac OS平台，10.8版本之前，一个显著的性能缺陷就是由于用了视图层级而不是单独在一个视图内使用CALayer树状层级。
但是在iOS平台，使用轻量级的UIView类并没有显著的性能影响（当然在Mac OS 10.8之后，NSView的性能同样也得到很大程度的提高）。</p>

<p>使用UIView而不是CALayer的好处在于，你能在使用所有CALayer底层特性的同时，也可以使用UIView的高级API（比如自动排版，布局和事件处理）。</p>

<p>然而，当满足以下条件的时候，你可能更需要使用CALayer而不是UIView
1.开发同时可以在Mac OS上运行的跨平台应用
2.使用多种CALayer的子类，并且不想创建额外的UIView
3.做一些对性能特别挑剔的工作，比如对UIView一些可忽略不计的操作都会引起显著的不同（尽管如此，你可能会直接想使用OpenGL绘图）</p>

<h2>2、图层中包含的图(The Backing Image)</h2>

<h3>1.content</h3>

<p>CALyer 有一个属性叫做contents，这个属性的类型被定义为id，意味着它可以是任何类型的对象。在这种情况下，你可以给contents属性赋任何值，你的app仍然能够编译通过。但是，在实践中，如果你给contents赋的不是CGImage，那么你得到的图层将是空白的。</p>

<p><strong>如果要给图层的寄宿图赋值，你可以按照以下这个方法：</strong></p>

<pre><code>layer.contents = (__bridge id)image.CGImage;
</code></pre>

<p><strong>把之前的例子修改一下</strong></p>

<pre><code>UIImage *image = [UIImage imageNamed:@"Snowman.png"];

//直接给layer的contents赋值
self.layerView.layer.contents = (__bridge id)image.CGImage;
</code></pre>

<p><strong>如下图</strong></p>

<p><img src="http://github-octopress.qiniudn.com/CoreAnimationAdvanced2.1.png" alt="Mou icon" /></p>

<h3>2.contentGravity</h3>

<p>我们加载的图片并不刚好是一个方的，为了适应这个视图，它有一点点被拉伸了。</p>

<p>在使用UIImageView的时候遇到过同样的问题，解决方法就是把contentMode属性设置成更合适的值，像这样：</p>

<pre><code>view.contentMode = UIViewContentModeScaleAspectFit;
</code></pre>

<p>不过UIView大多数视觉相关的属性比如contentMode，对这些属性的操作其实是对对应图层的操作。</p>

<p>CALayer与contentMode对应的属性叫做contentsGravity，但是它是一个NSString类型，而不是像对应的UIKit部分，那里面的值是枚举。contentsGravity可选的常量值有以下一些：</p>

<pre><code>kCAGravityCenter
kCAGravityTop
kCAGravityBottom
kCAGravityLeft
kCAGravityRight
kCAGravityTopLeft
kCAGravityTopRight
kCAGravityBottomLeft
kCAGravityBottomRight
kCAGravityResize
kCAGravityResizeAspect
kCAGravityResizeAspectFill
</code></pre>

<p>和cotentMode一样，contentsGravity的目的是为了决定内容在图层的边界中怎么对齐，我们将使用kCAGravityResizeAspect，它的效果等同于UIViewContentModeScaleAspectFit， 同时它还能在图层中等比例拉伸以适应图层的边界。</p>

<pre><code>self.layerView.layer.contentsGravity = kCAGravityResizeAspect;
</code></pre>

<p>如下所示</p>

<p><img src="http://github-octopress.qiniudn.com/CoreAnimationAdvanced2.2.png" alt="Mou icon" /></p>

<h3>3.ContentsScale</h3>

<p>contentsScale属性定义了寄宿图的像素尺寸和视图大小的比例，默认情况下它是一个值为1.0的浮点数。</p>

<p>contentsScale并不是总会对屏幕上的寄宿图有影响。如果你尝试对我们的例子设置不同的值，你就会发现根本没任何影响。因为contents由于设置了contentsGravity属性，所以它已经被拉伸以适应图层的边界。</p>

<p>如果你只是单纯地想放大图层的contents图片，你可以通过使用图层的transform和affineTransform属性来达到这个目的（见第五章『Transforms』，里面对此有解释），这(指放大)也不是contengsScale的目的所在.</p>

<p>contentsScale属性其实属于支持高分辨率（又称Hi-DPI或Retina）屏幕机制的一部分。它用来判断在绘制图层的时候应该为寄宿图创建的空间大小，和需要显示的图片的拉伸度（假设并没有设置contentsGravity属性）。UIView有一个类似功能但是非常少用到的contentScaleFactor属性。</p>

<p>如果contentsScale设置为1.0，将会以每个点1个像素绘制图片，如果设置为2.0，则会以每个点2个像素绘制图片，这就是我们熟知的Retina屏幕。</p>

<p>这并不会对我们在使用kCAGravityResizeAspect时产生任何影响，因为它就是拉伸图片以适应图层而已，根本不会考虑到分辨率问题。但是如果我们把contentsGravity设置为kCAGravityCenter，那将会有很明显的变化（<strong>如下所示</strong>）</p>

<p><img src="http://github-octopress.qiniudn.com/CoreAnimationAdvanced2.3.png" alt="Mou icon" /></p>

<p>我们的雪人不仅有点大还有点像素的颗粒感。那是因为和UIImage不同，CGImage没有拉伸的概念。当我们使用UIImage类去读取我们的雪人图片的时候，他读取了高质量的Retina版本的图片。但是当我们用CGImage来设置我们的图层的内容时，拉伸这个因素在转换的时候就丢失了。不过我们可以通过手动设置contentsScale来修复这个问题</p>

<pre><code>UIImage *image = [UIImage imageNamed:@"Snowman.png"]; //add it directly to our view's layer
self.layerView.layer.contents = (__bridge id)image.CGImage; //center the image
self.layerView.layer.contentsGravity = kCAGravityCenter;

//设置contentsScale以适应图片
self.layerView.layer.contentsScale = image.scale;
</code></pre>

<p><img src="http://github-octopress.qiniudn.com/CoreAnimationAdvanced2.4.png" alt="Mou icon" /></p>

<p>当用代码的方式来处理寄宿图的时候，一定要记住要手动的设置图层的contentsScale属性，否则，你的图片在Retina设备上就显示得不正确啦。代码如下：</p>

<pre><code>layer.contentsScale = [UIScreen mainScreen].scale;
</code></pre>

<h3>4.maskToBounds</h3>

<p>UIView有一个叫做clipsToBounds的属性可以用来决定是否显示超出边界的内容，CALayer对应的属性叫做masksToBounds，把它设置为YES，就不会显示超过图的范围了</p>

<p><img src="http://github-octopress.qiniudn.com/CoreAnimationAdvanced2.5.png" alt="Mou icon" /></p>

<h3>5.contentsRect</h3>

<p>CALayer的contentsRect属性允许我们在图层边框里显示寄宿图的一个子域。这涉及到图片是如何显示和拉伸的，所以要比contentsGravity灵活多了</p>

<p>和bounds，frame不同，contentsRect不是按点来计算的，它使用了单位坐标，单位坐标指定在0到1之间，是一个相对值（像素和点就是绝对值）。所以他们是相对与寄宿图的尺寸的。iOS使用了以下的坐标系统：</p>

<ul>
<li>点 —— 在iOS和Mac OS中最常见的坐标体系。点就像是虚拟的像素，也被称作逻辑像素。在标准设备上，一个点就是一个像素，但是在Retina设备上，一个点等于2*2个像素。iOS用点作为屏幕的坐标测算体系就是为了在Retina设备和普通设备上能有一致的视觉效果。</li>
<li>像素 —— 物理像素坐标并不会用来屏幕布局，但是仍然与图片有相对关系。UIImage是一个屏幕分辨率解决方案，所以指定点来度量大小。但是一些底层的图片表示如CGImage就会使用像素，所以你要清楚在Retina设备和普通设备上，他们表现出来了不同的大小。</li>
<li>单位 —— 对于与图片大小或是图层边界相关的显示，单位坐标是一个方便的度量方式， 当大小改变的时候，也不需要再次调整。单位坐标在OpenGL这种纹理坐标系统中用得很多，Core Animation中也用到了单位坐标。
默认的contentsRect是{0, 0, 1, 1}，这意味着整个图默认都是可见的，如果我们指定一个小一点的矩形，图片就会被裁剪</li>
</ul>


<p><img src="http://github-octopress.qiniudn.com/CoreAnimationAdvanced2.6.png" alt="Mou icon" /></p>

<p>事实上给contentsRect设置一个负数的原点或是大于{1, 1}的尺寸也是可以的。这种情况下，最外面的像素会被拉伸以填充剩下的区域。</p>

<p><strong>contentsRect在app中最有趣的地方在于一个叫做image sprites（图片拼合）的用法。</strong></p>

<p>典型地，图片拼合后可以打包整合到一张大图上一次性载入。相比多次载入不同的图片，这样做能够带来很多方面的好处：内存使用，载入时间，渲染性能等等</p>

<p>首先 ，我们需要一个拼合后的图标&ndash;一个包含小一些的拼合图的大图片，如图</p>

<p><img src="http://github-octopress.qiniudn.com/CoreAnimationAdvanced2.7.png" alt="Mou icon" /></p>

<p>接下来，像平常一样载入我们的大图，然后把它赋值给四个独立的图层的contents，然后设置每个图层的contentsRect来去掉我们不想显示的部分。</p>

<p>我们的工程中需要一些额外的视图。（为了避免太多代码。我们将使用Interface Builder来确定他们的位置，如果你愿意还是可以用代码的方式来实现的）。</p>

<pre><code>- (void)addSpriteImage:(UIImage *)image withContentRect:(CGRect)rect ￼toLayer:(CALayer *)layer //set image {

    layer.contents = (__bridge id)image.CGImage;

    //scale contents to fit
    layer.contentsGravity = kCAGravityResizeAspect;

    //set contentsRect
    layer.contentsRect = rect;
}

- (void)viewDidLoad  {
    [super viewDidLoad]; //load sprite sheet
    UIImage *image = [UIImage imageNamed:@"Sprites.png"];
    //set igloo sprite
    [self addSpriteImage:image withContentRect:CGRectMake(0, 0, 0.5, 0.5) toLayer:self.iglooView.layer];
    //set cone sprite
    [self addSpriteImage:image withContentRect:CGRectMake(0.5, 0, 0.5, 0.5) toLayer:self.coneView.layer];
    //set anchor sprite
    [self addSpriteImage:image withContentRect:CGRectMake(0, 0.5, 0.5, 0.5) toLayer:self.anchorView.layer];
    //set spaceship sprite
    [self addSpriteImage:image withContentRect:CGRectMake(0.5, 0.5, 0.5, 0.5) toLayer:self.shipView.layer];
}
</code></pre>

<p><img src="http://github-octopress.qiniudn.com/CoreAnimationAdvanced2.8.png" alt="Mou icon" /></p>

<p>拼合不仅给app提供了一个整洁的载入方式，还有效地提高了载入性能（单张大图比多张小图载入地更快），但是如果有手动安排的话，他们还是有一些不方便的，如果你需要在一个已经创建好的品和图上做一些尺寸上的修改或者其他变动，无疑是比较麻烦的。</p>

<p>Mac上有一些商业软件可以为你自动拼合图片，这些工具自动生成一个包含拼合后的坐标的XML或者plist文件，拼合图片的使用大大简化。这个文件可以和图片一同载入，并给每个拼合的图层设置contentsRect，这样开发者就不用手动写代码来摆放位置了。</p>

<p>这些文件通常在OpenGL游戏中使用，不过呢，你要是有兴趣在一些常见的app中使用拼合技术，那么一个叫做LayerSprites的开源库（<a href="https://github.com/nicklockwood/LayerSprites">https://github.com/nicklockwood/LayerSprites</a>)，它能够读取Cocos2D格式中的拼合图并在普通的Core Animation层中显示出来。</p>

<h3>6.contentsCenter</h3>

<p>contentsCenter其实是一个CGRect，它定义了一个固定的边框和一个在图层上可拉伸的区域。 改变contentsCenter的值并不会影响到寄宿图的显示，除非这个图层的大小改变了，你才看得到效果。</p>

<p>默认情况下，contentsCenter是{0, 0, 1, 1}，这意味着如果大小（由conttensGravity决定）改变了,那么寄宿图将会均匀地拉伸开。但是如果我们增加原点的值并减小尺寸。我们会在图片的周围创造一个边框。下图展示了contentsCenter设置为{0.25, 0.25, 0.5, 0.5}的效果。</p>

<p><img src="http://github-octopress.qiniudn.com/CoreAnimationAdvanced2.9.png" alt="Mou icon" /></p>

<p>他工作起来的效果和UIImage里的-resizableImageWithCapInsets: 方法效果非常类似，只是它可以运用到任何寄宿图，甚至包括在Core Graphics运行时绘制的图形</p>

<pre><code>- (void)addStretchableImage:(UIImage *)image withContentCenter:(CGRect)rect toLayer:(CALayer *)layer
{  
    //set image
    layer.contents = (__bridge id)image.CGImage;

    //set contentsCenter
    layer.contentsCenter = rect;
}

- (void)viewDidLoad
{
    [super viewDidLoad]; //load button image
    UIImage *image = [UIImage imageNamed:@"Button.png"];

    //set button 1
    [self addStretchableImage:image withContentCenter:CGRectMake(0.25, 0.25, 0.5, 0.5) toLayer:self.button1.layer];

    //set button 2
    [self addStretchableImage:image withContentCenter:CGRectMake(0.25, 0.25, 0.5, 0.5) toLayer:self.button2.layer];
}
</code></pre>

<h3>7.Custom Drawing</h3>

<p>给contents赋CGImage的值不是唯一的设置寄宿图的方法。我们也可以直接用Core Graphics直接绘制寄宿图。能够通过继承UIView并实现-drawRect:方法来自定义绘制。</p>

<p>-drawRect: 方法没有默认的实现，如果UIView检测到-drawRect: 方法被调用了，它就会为视图分配一个寄宿图，这个寄宿图的像素尺寸等于视图大小乘以 contentsScale的值。</p>

<p>如果你不需要寄宿图，那就不要创建这个方法了，这会造成CPU资源和内存的浪费，这也是为什么苹果建议：如果没有自定义绘制的任务就不要在子类中写一个空的-drawRect:方法。</p>

<p>当视图在屏幕上出现的时候 -drawRect:方法就会被自动调用。-drawRect:方法里面的代码利用Core Graphics去绘制一个寄宿图，然后内容就会被缓存起来直到它需要被更新（通常是因为开发者调用了-setNeedsDisplay方法，尽管影响到表现效果的属性值被更改时，一些视图类型会被自动重绘，如bounds属性）。虽然-drawRect:方法是一个UIView方法，事实上都是底层的CALayer安排了重绘工作和保存了因此产生的图片。</p>

<p>CALayer有一个可选的delegate属性，实现了CALayerDelegate协议，当CALayer需要一个内容特定的信息时，就会从协议中请求。CALayerDelegate是一个非正式协议，其实就是说没有CALayerDelegate @protocol可以让你在类里面引用啦。你只需要调用你想调用的方法，CALayer会帮你做剩下的。（delegate属性被声明为id类型，所有的代理方法都是可选的）。</p>

<p>当需要被重绘时，CALayer会请求它的代理给他一个寄宿图来显示。它通过调用下面这个方法做到的:</p>

<pre><code>- (void)displayLayer:(CALayerCALayer *)layer;
</code></pre>

<p>如果代理想直接设置contents属性的话，它就可以这么做，不然没有别的方法可以调用了。如果代理不实现-displayLayer:方法，CALayer就会转而尝试调用下面这个方法：</p>

<pre><code>- (void)drawLayer:(CALayer *)layer inContext:(CGContextRef)ctx;
</code></pre>

<p>在调用这个方法之前，CALayer创建了一个合适尺寸的空寄宿图（尺寸由bounds和contentsScale决定）和一个Core Graphics的绘制上下文环境，为绘制寄宿图做准备，他作为ctx参数传入。</p>

<p><strong>小例子：实现CALayerDelegate做一些绘图工作</strong></p>

<pre><code>@implementation ViewController
- (void)viewDidLoad
{
    [super viewDidLoad];
</code></pre>

<p>  ￼
        //create sublayer
        CALayer *blueLayer = [CALayer layer];
        blueLayer.frame = CGRectMake(50.0f, 50.0f, 100.0f, 100.0f);
        blueLayer.backgroundColor = [UIColor blueColor].CGColor;</p>

<pre><code>    //set controller as layer delegate
    blueLayer.delegate = self;

    //ensure that layer backing image uses correct scale
    blueLayer.contentsScale = [UIScreen mainScreen].scale; //add layer to our view
    [self.layerView.layer addSublayer:blueLayer];

    //force layer to redraw
    [blueLayer display];
}

- (void)drawLayer:(CALayer *)layer inContext:(CGContextRef)ctx
{
    //draw a thick red circle
    CGContextSetLineWidth(ctx, 10.0f); 
    CGContextSetStrokeColorWithColor(ctx, [UIColor redColor].CGColor);
    CGContextStrokeEllipseInRect(ctx, layer.bounds);
}
@end
</code></pre>

<p><img src="http://github-octopress.qiniudn.com/CoreAnimationAdvanced2.10.png" alt="Mou icon" /></p>

<p>注意一下一些有趣的事情：</p>

<ul>
<li>我们在blueLayer上显式地调用了-display。不同于UIView，当图层显示在屏幕上时，CALayer不会自动重绘它的内容。它把重绘的决定权交给了开发者。</li>
<li>尽管我们没有用masksToBounds属性，绘制的那个圆仍然沿边界被裁剪了。这是因为当你使用CALayerDelegate绘制寄宿图的时候，并没有对超出边界外的内容提供绘制支持。</li>
</ul>


<p>现在你理解了CALayerDelegate，并知道怎么使用它。但是除非你创建了一个单独的图层，你几乎没有机会用到CALayerDelegate协议。因为当UIView创建了它的宿主图层时，它就会自动地把图层的delegate设置为它自己，并提供了一个-displayLayer:的实现，那所有的问题就都没了。</p>

<p>当使用寄宿了视图的图层的时候，你也不必实现-displayLayer:和-drawLayer:inContext:方法绘制你的寄宿图。通常做法是实现UIView的-drawRect:方法，UIView就会帮你做完剩下的工作，包括在需要重绘的时候调用-display方法。</p>

		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2014-07-26T15:29:11+08:00" data-updated="true" itemprop="datePublished"></time></div>
		<div class="tags">


	<a class='category' href='/blog/categories/ios/'>ios</a>


</div>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/2014/07/26/realmshu-ju-ku-shi-yong-jie-shao-1/" itemprop="url">Realm数据库使用介绍</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<h2>1.背景介绍</h2>

<p>Realm是新出的移动端数据库，可以运行在手机、平板和可穿戴设备之上，其目标是取代CoreData和SQLite数据库。</p>

<p>Realm由YCombinator孵化的创业公司Realm制作，官网是<a href="http://realm.io/">http://realm.io/</a></p>

<p>目前支持 iOS 平台，提供 Swift 和 Objective-C的双支持</p>

<h2>2.如何安装</h2>

<h5>传统方式</h5>

<p>1、<a href="http://static.realm.io/downloads/cocoa/latest">点击下载最新版Realm</a></p>

<p>2、把Realm.framework拖到工程中，添加进去，确保这个framework是存在于你的项目中而不是只链接了引用</p>

<p>3、添加依赖库libc++.dylib</p>

<h5>CocoaPods方式</h5>

<p>1、在podfile中增加pod &ldquo;Realm&rdquo;</p>

<p>2、运行<code>pod install</code></p>

<p>3、打开<code>.xcworkspace</code>来运行你的项目</p>

<h2>3.使用介绍</h2>

<h3>1、Model</h3>

<p>Realm的数据Model是RLMObject的子类，添加相关的属性只需要直接用<code>@property NSString *name;</code>即可
,和其他NSObject一样，你也可以直接添加一些方法和协议并且直接用。</p>

<p>但是Realm的model是线程限制的。这意味着这个Model只能在创建它的线程中使用</p>

<p>Realm忽略了OC中属性的nonatomic/atomic/strong/copy/weak等，增加属性的时候也不需要加nonatomic之类，如果你加了，那么这些属性特征将会在RLMObject添加到realm时生效</p>

<p>举个例子，假设一个小狗有一个名字，那么这个小狗的Model就是这样</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// Dog 
</span><span class='line'>@interface Dog : RLMObject
</span><span class='line'>
</span><span class='line'>@property NSString *name;             // 狗的名字
</span><span class='line'>
</span><span class='line'>@end
</span><span class='line'>
</span><span class='line'>RLM_ARRAY_TYPE(Dog)
</span></code></pre></td></tr></table></div></figure>


<h3>2、关系</h3>

<p>多个Model之间可以有关系，譬如一对一，一对多，多对多</p>

<p>假设一个小狗不但有自己的名字，每只小狗还有自己的主人，那么就在Model中加入主人，只需要作为property加入即可。</p>

<p>而一个人可以拥有多条小狗，直接在Person的model中添加<code>@property RLMArray&lt;Dog&gt; *dogs;</code></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// Dog 
</span><span class='line'>@interface Dog : RLMObject
</span><span class='line'>
</span><span class='line'>@property NSString *name;             // 狗的名字
</span><span class='line'>@property NSString *color;            // 狗的毛色
</span><span class='line'>@property Person *owner;          // 狗的主人，一对一
</span><span class='line'>
</span><span class='line'>@end
</span><span class='line'>
</span><span class='line'>RLM_ARRAY_TYPE(Dog)
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>// Person
</span><span class='line'>@interface Person : RLMObject 
</span><span class='line'>
</span><span class='line'>@property NSString *name;         // 人名
</span><span class='line'>@property RLMArray&lt;Dog&gt; *dogs;      // 拥有的狗，表示可以拥有多条狗
</span><span class='line'>@property RLMArray&lt;House&gt; *houses;  // 拥有的房子
</span><span class='line'>
</span><span class='line'>@end
</span><span class='line'>
</span><span class='line'>RLM_ARRAY_TYPE(Person)
</span></code></pre></td></tr></table></div></figure>


<h5>具体使用如下</h5>

<p><strong>一对一</strong></p>

<pre><code>Person *xiaoxin = [[Person alloc] init];
Dog *dog = [[Dog alloc] init];
dog.name = @"littlewhite";
dog.color = @"white";
dog.owner = xiaoxin;  // 设置小白的主人为小新
</code></pre>

<p><strong>一对多</strong></p>

<pre><code>// 获取所有毛色中含有白色的小狗
RLMArray *someDogs = [Dog objectsWhere:@"color contains 'white'"];

xiaoxin.dogs = someDogs;
[xiaoxin.dogs addObject:dog];
</code></pre>

<p>注意：RLMArray 属性意味着赋值时复制，property直接赋值将赋值对象的引用。</p>

<h3>3、具体操作</h3>

<h4>3.1、增删改如何实现</h4>

<p>一个对象的增删改都可以通过<code>beginWriteTransaction</code> <code>commitWriteTransaction</code>来实现</p>

<p>因为Realm采用的MVCC结构，读事务不会因为写事务正在执行而阻塞</p>

<p>因为model不能在线程中共享，要使用只能先添加到Realm中,只要使用相同的Realm数据库，就可以在多个线程中共享数据</p>

<p>如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// 创建对象
</span><span class='line'>Person *author = [[Person alloc] init];
</span><span class='line'>author.name    = @"David Foster Wallace";
</span><span class='line'>
</span><span class='line'>// 获取数据库
</span><span class='line'>RLMRealm *realm = [RLMRealm defaultRealm];
</span><span class='line'>
</span><span class='line'>// 添加到数据库
</span><span class='line'>[realm beginWriteTransaction];
</span><span class='line'>[realm addObject:author];
</span><span class='line'>[realm commitWriteTransaction];</span></code></pre></td></tr></table></div></figure>


<h4>3.2、查询</h4>

<p>调用查询语句之后得到的结果是存储这RLMObject数据的RLMArray类型的数组，RLMArray其他特性和NSArray一样</p>

<p>如下，要查询数据库中存储的所有狗，只需要调用Dog这个Model的allObject方法</p>

<pre><code>RLMArray *dogs = [Dog allObjects];
</code></pre>

<p>但是上述的查询是在默认数据库中执行，要是想指定一个数据库，就需要</p>

<pre><code>// 获得指定的数据库 
RLMRealm *petsRealm = [RLMRealm realmWithPath:@"pets.realm"]; 
// 从这个数据库中查询所有的小狗
RLMArray *otherDogs = [Dog allObjectsInRealm:petsRealm];
</code></pre>

<h5>3.2.1、条件查询</h5>

<p>可以使用<code>[RLMObject objectsWhere:]</code>直接写查询条件，也可以使用<code>NSPredicate</code></p>

<pre><code>// 使用ObjectWhere:做查询条件
RLMArray *tanDogs = [Dog objectsWhere:@"color = 'tan' AND name BEGINSWITH 'B'"];

// 使用NSPredicate也有同样的效果
NSPredicate *pred = [NSPredicate predicateWithFormat:@"color = %@ AND name BEGINSWITH %@", @"tan", @"B"];
RLMArray *tanDogs2 = [Dog objectsWithPredicate:pred];
</code></pre>

<h4>3.3、结果排序</h4>

<p>结果排序非常简单，使用RLMArray的方法arraySortedByProperty:ascending: 即可</p>

<p>property中输入要排序的字段名</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// 指定一个排序的字段名，默认是升序
</span><span class='line'>RLMArray *sortedDogs = [[Dog objectsWhere:@"color = 'tan' AND name BEGINSWITH 'B'"]
</span><span class='line'>                    arraySortedByProperty:@"name" ascending:YES];</span></code></pre></td></tr></table></div></figure>


<h4>3.4、链式查询</h4>

<p>就是说如果用一些条件已经查询出一个RLMArray数组，还可以继续用这个数组进行条件查询</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>RLMArray *tanDogs = [Dog objectsWhere:@"color = 'tan'"];
</span><span class='line'>RLMArray *tanDogsWithBNames = [tanDogs objectsWhere:@"name BEGINSWITH 'B'"];</span></code></pre></td></tr></table></div></figure>


<h3>4、Realm数据库</h3>

<p>默认的Realm数据库可以通过<code>[RLMRealm defaultRealm]</code>获得，默认的数据库保存在documents目录下，名字为default.realm， 写事务将自动写入磁盘</p>

<h4>4.1、使用内存中的默认数据库</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[RLMRealm useInMemoryDefaultRealm]; 
</span><span class='line'>RLMRealm *realm = [RLMRealm defaultRealm]; // 只能在useInMemoryDefaultRealm之后调用</span></code></pre></td></tr></table></div></figure>


<p>这个只对默认数据库有效，而且如果在内存中使用数据库，将无法存储RLMObject,这意味着在app运行中都不能保存数据，但是这个对访问复杂数据很有用，避免了磁盘开销</p>

<h4>4.2、其他数据库</h4>

<p>还可以使用<code>[RLMRealm realmWithPath:]</code> <code>[RLMRealm realmWithPath:readOnly:error:]</code>来获得别的数据库</p>

<h4>4.3、线程间使用Realm数据库</h4>

<p>要在多个线程间访问同一个数据库，可以用<code>[RLMRealm defaultRealm]</code> <code>[RLMRealm realmWithPath:]</code> 或者 <code>[RLMRealm realmWithPath:readOnly:error:]</code>在每一个线程中获得相应的数据库对象。只要地址用的对，数据库肯定是同一个，但是<code>不要在线程间共享RLMRealm对象</code>。有多个Realm对象指向同样的文件地址，这个是没有问题的，甚至可以同一个线程中有多个Realm对象指向同一个文件地址，也是安全的。</p>

<h3>5、通知</h3>

<p>当Realm更新的时候会发出通知，可以注册一个block 来响应通知</p>

<pre><code>self.token = [realm addNotificationBlock:^(NSString *note, RLMRealm *realm) {
    [muViewController updateUI];
}];
</code></pre>

<p>还可以用<code>[Realm removeNotificationBlock:]</code>移除block</p>

<h3>6、后台操作</h3>

<p>Realm在大数据写入上非常有效率。事务可以使用GCD在后台实施，从而避免阻塞主线程。RLMRealm不是县城安全的，也不能在线程中共享，因此当需要读写数据库时，必须在每个线程或调度队列里获取一个RLMRealm实例。</p>

<p>下面是一个后台插入百万级数据的例子</p>

<pre><code>dispatch_async(queue, ^{
    RLMRealm *realm = [RLMRealm defaultRealm];

    for (NSInteger idx1 = 0; idx1 &lt; 1000; idx1++) {
        [realm beginWriteTransaction];
        for (NSInteger idx2 = 0; idx2 &lt; 1000; idx2++) {
            [Person createInRealm:realm
                    withObject:@{@"name : [self randomString],
                                 @"birthdate" : [self randomDate]}];
        }
        [realm commitWriteTransaction];
    }
});
</code></pre>

		
		
	</div>

</article>

</div>
<nav id="pagenavi">
    
        <a href="1" class="prev">Prev</a>
    
    
    <div class="center"><a href="/blog/archives">Blog Archives</a></div>
</nav></div>
			</div>
			<footer id="footer" class="inner">Copyright &copy; 2015

    Joy Long


Design credit: <a href="http://shashankmehta.in/archive/2012/greyshade.html">Shashank Mehta</a></footer>
			<script src="/javascripts/slash.js"></script>
<script src="/javascripts/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
	$('.fancybox').fancybox();
})(jQuery);
</script> <!-- Delete or comment this line to disable Fancybox -->






		</div>
	</div>
</body>
</html>
