<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ios-coreanimation | 代码萝卜]]></title>
  <link href="http://joylong.github.io/blog/categories/ios-coreanimation/atom.xml" rel="self"/>
  <link href="http://joylong.github.io/"/>
  <updated>2015-07-26T00:24:16+08:00</updated>
  <id>http://joylong.github.io/</id>
  <author>
    <name><![CDATA[Joy Long]]></name>
    <email><![CDATA[joylong.ly@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Core Animation Advanced Technique 学习笔记(9)]]></title>
    <link href="http://joylong.github.io/blog/2014/09/07/core-animation-advanced-technique-9/"/>
    <updated>2014-09-07T20:06:08+08:00</updated>
    <id>http://joylong.github.io/blog/2014/09/07/core-animation-advanced-technique-9</id>
    <content type="html"><![CDATA[<h1>第二部分：运动中的设置</h1>

<h2>10、缓冲</h2>

<h3>10.1、动画速率</h3>

<p>动画实际上是一段时间内的变化，这就暗示了变化一定是随着某个特定的速率进行。</p>

<p>速率由以下公式计算而来：</p>

<pre><code>velocity = change / time
</code></pre>

<p>这里的变化可以指的是一个物体移动的距离，时间指动画持续的时长，但实际上动画应用于任意可以做动画的属性（譬如color和opacity）。</p>

<p>上面的等式假设了速率在整个动画过程中都是恒定不变的，对于这种恒定速率的动画我们称之为“线性滨化”，从技术的角度而言这是实现动画最简单的方式，但也是完全不真实的一种效果。</p>

<p>现实生活中的任何一个物体都会在运动中加速或者减速。</p>

<p>那么我们如何在动画中实现这种加速度呢？</p>

<p>Core Animation内嵌了一系列标准函数提供给我们使用。</p>

<h4>10.1.1、CAMediaTimingFunction</h4>

<p>CAAnimation的timingFunction属性，是CAMediaTimingFunction类的一个对象。</p>

<p>如果想改变隐式动画的计时函数，同样也可以使用CATransaction的+setAnimationTimingFunction:方法。</p>

<p>要创建CAMediaTimingFunction，最简单的就是调用+timingFunctionWithName:的构造方法。传入如下几个常量之一：</p>

<ul>
<li><p>kCAMediaTimingFunctionLinear</p>

<p>线性的计时函数，同样也是CAAnimation的timingFunction属性为空时候的默认函数</p></li>
<li><p>kCAMediaTimingFunctionEaseIn</p>

<p>慢慢加速然后突然停止。适用于自由落体等</p></li>
<li><p>kCAMediaTimingFunctionEaseOut</p>

<p>全速开始，然后慢慢减速停止。它有一个削弱的效果，应用的场景比如一扇门慢慢地关上，而不是砰地一声</p></li>
<li><p>kCAMediaTimingFunctionEaseInEaseOut</p>

<p>慢慢加速然后再慢慢减速。这是现实世界大多数物体移动的方式，也是大多数动画来说最好的选择。</p>

<p>如果只可以用一种缓冲函数的话，那就必须是它了。当使用UIView的动画方法时，默认是这个选项，但当创建CAAnimation的时候，就需要手动设置了。</p></li>
<li><p>kCAMediaTimingFunctionDefault</p>

<p>和kCAMediaTimingFunctionEaseInEaseOut很类似，但是加速和减速都稍微有些慢。</p>

<p>和kCAMediaTimingFunctionEaseInEaseOut的区别很难察觉，可能是苹果觉得它对于隐式动画来说更适合（然后对UIKit就改变了想法，而是使用kCAMediaTimingFunctionEaseInEaseOut作为默认效果）</p>

<p>虽说名字写是默认的，当创建显式的CAAnimation它并不是默认选项（换句话说，默认的图层行为动画用kCAMediaTimingFunctionDefault作为它们的计时方法）。</p></li>
</ul>


<p>小例子：缓冲函数的简单测试(在运行之前改变缓冲函数的代码，然后点击任何地方来观察图层是如何通过指定的缓冲移动的)</p>

<pre><code>@interface ViewController ()

@property (nonatomic, strong) CALayer *colorLayer;

@end

@implementation ViewController

- (void)viewDidLoad
{
    [super viewDidLoad];
    // 创建红色图层
    self.colorLayer = [CALayer layer];
    self.colorLayer.frame = CGRectMake(0, 0, 100, 100);
    self.colorLayer.position = CGPointMake(self.view.bounds.size.width/2.0, self.view.bounds.size.height/2.0);
    self.colorLayer.backgroundColor = [UIColor redColor].CGColor;
    [self.view.layer addSublayer:self.colorLayer];
}

- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event
{
    // 配置事务
    [CATransaction begin];
    [CATransaction setAnimationDuration:1.0];
    [CATransaction setAnimationTimingFunction:[CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseOut]];
    // 设置位置
    self.colorLayer.position = [[touches anyObject] locationInView:self.view];
    // 提交事务
    [CATransaction commit];
}

@end
</code></pre>

<h4>10.1.2、UIView动画缓冲</h4>

<p>UIKit的动画也支持这些缓冲方法，只是语法和常量有些不同。</p>

<p>为了改变UIView动画的缓冲选项，给options参数添加如下常量之一：</p>

<pre><code>UIViewAnimationOptionCurveEaseInOut  // 默认值
UIViewAnimationOptionCurveEaseIn 
UIViewAnimationOptionCurveEaseOut 
UIViewAnimationOptionCurveLinear
</code></pre>

<p>和CAMediaTimingFunction差不多，只是没有kCAMediaTimingFunctionDefault对应的值了。</p>

<p>小例子：使用UIKit动画的缓冲</p>

<pre><code>@interface ViewController ()

@property (nonatomic, strong) UIView *colorView;

@end

@implementation ViewController

- (void)viewDidLoad
{
    [super viewDidLoad];
    // 创建红色图层
    self.colorView = [[UIView alloc] init];
    self.colorView.bounds = CGRectMake(0, 0, 100, 100);
    self.colorView.center = CGPointMake(self.view.bounds.size.width / 2, self.view.bounds.size.height / 2);
    self.colorView.backgroundColor = [UIColor redColor];
    [self.view addSubview:self.colorView];
}

- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event
{
    // 实施动画
    [UIView animateWithDuration:1.0 delay:0.0
                        options:UIViewAnimationOptionCurveEaseOut
                    animations:^{
                            //set the position
                            self.colorView.center = [[touches anyObject] locationInView:self.view];
                        }
                    completion:NULL];

}

@end
</code></pre>

<h4>10.1.3、缓冲和关键帧动画</h4>

<p>之前讲到关键帧动画时：有个颜色切换的关键帧动画由于线性变换的原因看起来有些奇怪，使得颜色变换非常不自然。为了改善变换，可以用更加合适的缓冲方法，例如kCAMediaTimingFunctionEaseIn，给图层的颜色变化添加一点缓冲效果，让它更像现实中的一个彩色灯泡。</p>

<p>CAKeyframeAnimation有一个NSArray类型的timingFunctions属性，我们可以用它来对每次动画的步骤指定不同的计时函数。</p>

<p>但是指定函数的个数一定要等于keyframes数组的元素个数减一，因为它是描述每一帧<code>之间</code>动画速度的函数。</p>

<p>小例子：对CAKeyframeAnimation使用CAMediaTimingFunction</p>

<pre><code>@interface ViewController ()

@property (nonatomic, weak) IBOutlet UIView *layerView;
@property (nonatomic, weak) IBOutlet CALayer *colorLayer;

@end

@implementation ViewController

- (void)viewDidLoad
{
    [super viewDidLoad];
    // 创建子图层
    self.colorLayer = [CALayer layer];
    self.colorLayer.frame = CGRectMake(50.0f, 50.0f, 100.0f, 100.0f);
    self.colorLayer.backgroundColor = [UIColor blueColor].CGColor;
    // 添加到视图
    [self.layerView.layer addSublayer:self.colorLayer];
}

- (IBAction)changeColor
{
    // 创建关键帧动画
    CAKeyframeAnimation *animation = [CAKeyframeAnimation animation];
    animation.keyPath = @"backgroundColor";
    animation.duration = 2.0;
    animation.values = @[
                         (__bridge id)[UIColor blueColor].CGColor,
                         (__bridge id)[UIColor redColor].CGColor,
                         (__bridge id)[UIColor greenColor].CGColor,
                         (__bridge id)[UIColor blueColor].CGColor ];
    // 添加计时函数
    CAMediaTimingFunction *fn = [CAMediaTimingFunction functionWithName: kCAMediaTimingFunctionEaseIn];
    animation.timingFunctions = @[fn, fn, fn];
    // 应用动画到图层上
    [self.colorLayer addAnimation:animation forKey:nil];
}

@end
</code></pre>

<h3>10.2、自定义缓冲函数</h3>

<p>在现实世界中，钟表指针转动的时候，通常起步很慢，然后迅速啪地一声，最后缓冲到终点。</p>

<p>但是预设的缓冲函数没有适合这种方式的，那该如何创建一个新的呢？</p>

<p>除了+functionWithName:之外，CAMediaTimingFunction同样有另一个构造函数，一个有四个浮点参数的+functionWithControlPoints::::（注意这里奇怪的语法，并没有包含具体每个参数的名称，这在objective-C中是合法的，但是却违反了苹果对方法命名的指导方针，而且看起来是一个奇怪的设计）。</p>

<p>使用这个方法，我们可以创建一个自定义的缓冲函数，来匹配我们的时钟动画，为了理解如何使用这个方法，我们要了解一些CAMediaTimingFunction是如何工作的。</p>

<h4>10.2.1、三次贝塞尔曲线</h4>

<p>CAMediaTimingFunction函数把输入的时间转换成起点和终点之间成比例的改变。</p>

<p>可以用一个简单的图标来解释，横轴代表时间，纵轴代表改变的量，于是线性的缓冲就是一条从起点开始的简单的斜线。</p>

<p><img src="http://github-octopress.qiniudn.com/CoreAnimationAdvanced10.1.png" alt="Mou icon" /></p>

<p>这条曲线的斜率代表了速度，斜率的改变代表了加速度，原则上来说，任何加速的曲线都可以用这种图像来表示，但是CAMediaTimingFunction使用了一个叫做三次贝塞尔曲线的函数，它只可以产出指定缓冲函数的子集。</p>

<p>一个三次贝塞尔曲线通过四个点来定义，第一个和最后一个点代表了曲线的起点和终点，剩下中间两个点叫做控制点，因为它们控制了曲线的形状，贝塞尔曲线的控制点其实是位于曲线之外的点，也就是说曲线并不一定要穿过它们。你可以把它们想象成吸引经过它们曲线的磁铁。</p>

<p><img src="http://github-octopress.qiniudn.com/CoreAnimationAdvanced10.2.png" alt="Mou icon" /></p>

<p>实际上它是一个很奇怪的函数，先加速，然后减速，最后快到达终点的时候又加速，那么标准的缓冲函数又该如何用图像来表示呢？</p>

<p>CAMediaTimingFunction有一个getControlPointAtIndex:values:的方法，可以用来检索曲线的点，使用它我们可以找到标准缓冲函数的点，然后用UIBezierPath和CAShapeLayer来把它画出来。</p>

<p>曲线的起始和终点始终是{0, 0}和{1, 1}，于是我们只需要检索曲线的第二个和第三个点（控制点）。</p>

<p>小例子：使用UIBezierPath绘制CAMediaTimingFunction</p>

<pre><code>@interface ViewController ()

@property (nonatomic, weak) IBOutlet UIView *layerView;

@end

@implementation ViewController

- (void)viewDidLoad
{
    [super viewDidLoad];
    // 创建计时函数
    CAMediaTimingFunction *function = CAMediaTimingFunction functionWithName: kCAMediaTimingFunctionEaseOut];
    // 获得控制点
    CGPoint controlPoint1, controlPoint2;
    [function getControlPointAtIndex:1 values:(float *)&amp;controlPoint1];
    [function getControlPointAtIndex:2 values:(float *)&amp;controlPoint2];
    // 创建曲线
    UIBezierPath *path = [[UIBezierPath alloc] init];
    [path moveToPoint:CGPointZero];
    [path addCurveToPoint:CGPointMake(1, 1)
        controlPoint1:controlPoint1 controlPoint2:controlPoint2];
    // 缩放路径到可显示状态
    [path applyTransform:CGAffineTransformMakeScale(200, 200)];
    // 创建CAShapeLayer
    CAShapeLayer *shapeLayer = [CAShapeLayer layer];
    shapeLayer.strokeColor = [UIColor redColor].CGColor;
    shapeLayer.fillColor = [UIColor clearColor].CGColor;
    shapeLayer.lineWidth = 4.0f;
    shapeLayer.path = path.CGPath;
    [self.layerView.layer addSublayer:shapeLayer];
    // flip geometry so that 0,0 is in the bottom-left
    self.layerView.layer.geometryFlipped = YES;
}

@end
</code></pre>

<p><img src="http://github-octopress.qiniudn.com/CoreAnimationAdvanced10.3.png" alt="Mou icon" /></p>

<p>那么对于我们自定义时钟指针的缓冲函数来说，我们需要初始微弱，然后迅速上升，最后缓冲到终点的曲线，通过一些实验之后，最终结果如下：</p>

<pre><code>[CAMediaTimingFunction functionWithControlPoints:1 :0 :0.75 :1];
</code></pre>

<p>如果把它转换成缓冲函数的图像，如下图：</p>

<p><img src="http://github-octopress.qiniudn.com/CoreAnimationAdvanced10.4.png" alt="Mou icon" /></p>

<p>如果把它添加到时钟的程序，就形成了之前一直期待的非常赞的效果。</p>

<p>小例子：添加了自定义缓冲函数的时钟程序</p>

<pre><code>- (void)setAngle:(CGFloat)angle forHand:(UIView *)handView ￼animated:(BOOL)animated
{
    // 生成变换
    CATransform3D transform = CATransform3DMakeRotation(angle, 0, 0, 1);
    if (animated) {
        // 创建变换动画
        CABasicAnimation *animation = [CABasicAnimation animation];
        animation.keyPath = @"transform";
        animation.fromValue = [handView.layer.presentationLayer valueForKey:@"transform"];
        animation.toValue = [NSValue valueWithCATransform3D:transform];
        animation.duration = 0.5;
        animation.delegate = self;
        animation.timingFunction = [CAMediaTimingFunction functionWithControlPoints:1 :0 :0.75 :1];
        // 应用动画
        handView.layer.transform = transform;
        [handView.layer addAnimation:animation forKey:nil];
    } else {
        // 直接设置变换
        handView.layer.transform = transform;
    }
}
</code></pre>

<h4>10.2.2、更加复杂的动画缓冲</h4>

<p>考虑一个橡胶球掉落到坚硬的地面的场景，当开始下落的时候，它会持续加速知道落到地面，然后经过几次反弹，最后停下来。如果用一张图来说明，如下图。</p>

<p><img src="http://github-octopress.qiniudn.com/CoreAnimationAdvanced10.5.png" alt="Mou icon" /></p>

<p>这种效果没法用一个简单的三次贝塞尔曲线表示，于是不能用CAMediaTimingFunction来完成。但如果想要实现这样的效果，可以用如下几种方法：</p>

<ul>
<li><p>用CAKeyframeAnimation创建一个动画，然后分割成几个步骤，每个小步骤使用自己的计时函数。</p></li>
<li><p>使用定时器逐帧更新实现动画。</p></li>
</ul>


<h4>10.2.3、基于关键帧的缓冲</h4>

<p>为了使用关键帧实现反弹动画，我们需要在缓冲曲线中对每一个显著的点创建一个关键帧（在这个情况下，关键点也就是每次反弹的峰值），然后应用缓冲函数把每段曲线连接起来。同时，我们也需要通过keyTimes来指定每个关键帧的时间偏移，由于每次反弹的时间都会减少，于是关键帧并不会均匀分布。</p>

<p>小例子：使用关键帧实现反弹球的动画</p>

<pre><code>@interface ViewController ()

@property (nonatomic, weak) IBOutlet UIView *containerView;
@property (nonatomic, strong) UIImageView *ballView;

@end

@implementation ViewController

- (void)viewDidLoad
{
    [super viewDidLoad];
    // 添加球的图片
    UIImage *ballImage = [UIImage imageNamed:@"Ball.png"];
    self.ballView = [[UIImageView alloc] initWithImage:ballImage];
    [self.containerView addSubview:self.ballView];
    // 开始动画
    [self animate];
}

- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event
{
    // 点击重播动画
    [self animate];
}

- (void)animate
{
    // 重置球到屏幕顶部
    self.ballView.center = CGPointMake(150, 32);
    // 创建关键帧动画
    CAKeyframeAnimation *animation = [CAKeyframeAnimation animation];
    animation.keyPath = @"position";
    animation.duration = 1.0;
    animation.delegate = self;
    animation.values = @[
                         [NSValue valueWithCGPoint:CGPointMake(150, 32)],
                         [NSValue valueWithCGPoint:CGPointMake(150, 268)],
                         [NSValue valueWithCGPoint:CGPointMake(150, 140)],
                         [NSValue valueWithCGPoint:CGPointMake(150, 268)],
                         [NSValue valueWithCGPoint:CGPointMake(150, 220)],
                         [NSValue valueWithCGPoint:CGPointMake(150, 268)],
                         [NSValue valueWithCGPoint:CGPointMake(150, 250)],
                         [NSValue valueWithCGPoint:CGPointMake(150, 268)]
                        ];

    animation.timingFunctions = @[
                              [CAMediaTimingFunction functionWithName: kCAMediaTimingFunctionEaseIn],
                              [CAMediaTimingFunction functionWithName: kCAMediaTimingFunctionEaseOut],
                              [CAMediaTimingFunction functionWithName: kCAMediaTimingFunctionEaseIn],
                              [CAMediaTimingFunction functionWithName: kCAMediaTimingFunctionEaseOut],
                              [CAMediaTimingFunction functionWithName: kCAMediaTimingFunctionEaseIn],
                              [CAMediaTimingFunction functionWithName: kCAMediaTimingFunctionEaseOut],
                              [CAMediaTimingFunction functionWithName: kCAMediaTimingFunctionEaseIn]
                              ];

    animation.keyTimes = @[@0.0, @0.3, @0.5, @0.7, @0.8, @0.9, @0.95, @1.0];
    // 应用动画
    self.ballView.layer.position = CGPointMake(150, 268);
    [self.ballView.layer addAnimation:animation forKey:nil];
}

@end
</code></pre>

<p><img src="http://github-octopress.qiniudn.com/CoreAnimationAdvanced10.6.png" alt="Mou icon" /></p>

<p>这种方式还算不错，但是实现起来略显笨重（因为要不停地尝试计算各种关键帧和时间偏移）并且和动画强绑定了（因为如果要改变动画的一个属性，那就意味着要重新计算所有的关键帧）。那该如何写一个方法，用缓冲函数来把任何简单的属性动画转换成关键帧动画呢，下面我们来实现它。</p>

<h4>10.2.4、过程自动化</h4>

<p>之前的例子中，把动画分割成相当大的几块，然后用Core Animation的缓冲进入和缓冲退出函数来大约形成我们想要的曲线。</p>

<p>但如果把动画分割成更小的几部分，那么就可以用直线来拼接这些曲线（也就是线性缓冲）。</p>

<p>为了实现自动化，我们需要知道如何做如下两件事情：</p>

<ul>
<li><p>自动把任意属性动画分割成多个关键帧</p></li>
<li><p>用一个数学函数表示弹性动画，使得可以对帧做便宜</p></li>
</ul>


<p>为了解决第一个问题，我们需要复制Core Animation的插值机制。</p>

<p>这是一个传入起点和终点，然后在这两个点之间指定时间点产出一个新点的机制。对于简单的浮点起始值，公式如下（假设时间从0到1）：</p>

<pre><code>value = (endValue – startValue) × time + startValue;
</code></pre>

<p>那么如果要插入一个类似于CGPoint，CGColorRef或者CATransform3D这种更加复杂类型的值，我们可以简单地对每个独立的元素应用这个方法（也就CGPoint中的x和y值，CGColorRef中的红，蓝，绿，透明值，或者是CATransform3D中独立矩阵的坐标）。</p>

<p>同样需要一些逻辑在插值之前对对象拆解值，然后在插值之后在重新封装成对象，也就是说需要实时地检查类型。</p>

<p>一旦我们可以用代码获取属性动画的起始值之间的任意插值，我们就可以把动画分割成许多独立的关键帧，然后产出一个线性的关键帧动画。</p>

<p>注意到我们用了60 x 动画时间（秒做单位）作为关键帧的个数，这时因为Core Animation按照每秒60帧去渲染屏幕更新，所以如果我们每秒生成60个关键帧，就可以保证动画足够的平滑（尽管实际上很可能用更少的帧率就可以达到很好的效果）。</p>

<p>小例子：使用插入的值创建一个关键帧动画</p>

<pre><code>float interpolate(float from, float to, float time)
{
    return (to - from) * time + from;
}

- (id)interpolateFromValue:(id)fromValue toValue:(id)toValue time:(float)time
{
    if ([fromValue isKindOfClass:[NSValue class]]) {
        // 获得类型
        const char *type = [fromValue objCType];
        if (strcmp(type, @encode(CGPoint)) == 0) {
            CGPoint from = [fromValue CGPointValue];
            CGPoint to = [toValue CGPointValue];
            CGPoint result = CGPointMake(interpolate(from.x, to.x, time), interpolate(from.y, to.y, time));
            return [NSValue valueWithCGPoint:result];
        }
    }
    // 提供安全的默认值
    return (time &lt; 0.5)? fromValue: toValue;
}

- (void)animate
{
    // 重置视图位置
    self.ballView.center = CGPointMake(150, 32);
    // 设置动画参数
    NSValue *fromValue = [NSValue valueWithCGPoint:CGPointMake(150, 32)];
    NSValue *toValue = [NSValue valueWithCGPoint:CGPointMake(150, 268)];
    CFTimeInterval duration = 1.0;
    // 生成关键帧
    NSInteger numFrames = duration * 60;
    NSMutableArray *frames = [NSMutableArray array];
    for (int i = 0; i &lt; numFrames; i++) {
        float time = 1 / (float)numFrames * i;
        [frames addObject:[self interpolateFromValue:fromValue toValue:toValue time:time]];
    }
    // 创建关键帧动画
    CAKeyframeAnimation *animation = [CAKeyframeAnimation animation];
    animation.keyPath = @"position";
    animation.duration = 1.0;
    animation.delegate = self;
    animation.values = frames;
    // 应用动画
    [self.ballView.layer addAnimation:animation forKey:nil];
}
</code></pre>

<p>这可以起到作用，但效果并不是很好，到目前为止我们所完成的只是一个非常复杂的方式来使用线性缓冲复制CABasicAnimation的行为。</p>

<p>这种方式的好处在于我们可以更加精确地控制缓冲，这也意味着我们可以应用一个完全定制的缓冲函数。那么该如何做呢？</p>

<p>缓冲背后的数学并不很简单，但是幸运的是我们不需要一一实现它。罗伯特·彭纳有一个网页关于缓冲函数（<a href="http://www.robertpenner.com/easing%EF%BC%89%EF%BC%8C%E5%8C%85%E5%90%AB%E4%BA%86%E5%A4%A7%E5%A4%9A%E6%95%B0%E6%99%AE%E9%81%8D%E7%9A%84%E7%BC%93%E5%86%B2%E5%87%BD%E6%95%B0%E7%9A%84%E5%A4%9A%E7%A7%8D%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%9A%84%E9%93%BE%E6%8E%A5%EF%BC%8C%E5%8C%85%E6%8B%ACC%E3%80%82">http://www.robertpenner.com/easing%EF%BC%89%EF%BC%8C%E5%8C%85%E5%90%AB%E4%BA%86%E5%A4%A7%E5%A4%9A%E6%95%B0%E6%99%AE%E9%81%8D%E7%9A%84%E7%BC%93%E5%86%B2%E5%87%BD%E6%95%B0%E7%9A%84%E5%A4%9A%E7%A7%8D%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%9A%84%E9%93%BE%E6%8E%A5%EF%BC%8C%E5%8C%85%E6%8B%ACC%E3%80%82</a></p>

<p>这里是一个缓冲进入缓冲退出函数的示例（实际上有很多不同的方式去实现它）。</p>

<pre><code>float quadraticEaseInOut(float t) 
{
    return (t &lt; 0.5)? (2 * t * t): (-2 * t * t) + (4 * t) - 1; 
}
</code></pre>

<p>对我们的弹性球来说，我们可以使用bounceEaseOut函数：</p>

<pre><code>float bounceEaseOut(float t)
{
    if (t &lt; 4/11.0) {
        return (121 * t * t)/16.0;
    } else if (t &lt; 8/11.0) {
        return (363/40.0 * t * t) - (99/10.0 * t) + 17/5.0;
    } else if (t &lt; 9/10.0) {
        return (4356/361.0 * t * t) - (35442/1805.0 * t) + 16061/1805.0;
    }
    return (54/5.0 * t * t) - (513/25.0 * t) + 268/25.0;
}
</code></pre>

<p>小例子：用关键帧实现自定义的缓冲函数</p>

<pre><code>- (void)animate
{
    // reset ball to top of screen
    self.ballView.center = CGPointMake(150, 32);
    // set up animation parameters
    NSValue *fromValue = [NSValue valueWithCGPoint:CGPointMake(150, 32)];
    NSValue *toValue = [NSValue valueWithCGPoint:CGPointMake(150, 268)];
    CFTimeInterval duration = 1.0;
    // generate keyframes
    NSInteger numFrames = duration * 60;
    NSMutableArray *frames = [NSMutableArray array];
    for (int i = 0; i &lt; numFrames; i++) {
        float time = 1/(float)numFrames * i;
        //apply easing
        time = bounceEaseOut(time);
        //add keyframe
        [frames addObject:[self interpolateFromValue:fromValue toValue:toValue time:time]];
    }
    // create keyframe animation
    CAKeyframeAnimation *animation = [CAKeyframeAnimation animation];
    animation.keyPath = @"position";
    animation.duration = 1.0;
    animation.delegate = self;
    animation.values = frames;
    // apply animation
    [self.ballView.layer addAnimation:animation forKey:nil];
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Core Animation Advanced Technique 学习笔记(8)]]></title>
    <link href="http://joylong.github.io/blog/2014/09/07/core-animation-advanced-technique-8/"/>
    <updated>2014-09-07T16:06:08+08:00</updated>
    <id>http://joylong.github.io/blog/2014/09/07/core-animation-advanced-technique-8</id>
    <content type="html"><![CDATA[<h1>第二部分：运动中的设置</h1>

<h2>9、图层时间</h2>

<h3>9.1、CAMediaTiming协议</h3>

<p>CAMediaTiming协议定义了在一段动画内用来控制已进行时间的属性的集合，CALayer和CAAnimation都实现了这个协议，所以时间可以被任意基于一个图层或者一段动画的类控制。</p>

<h4>9.1.1、持续和重复</h4>

<p>CAMediaTiming有一个属性叫duration，duration是CFTimeInterval类型（和NSTimeInterval类似的双精度浮点类型）表示一次动画执行的时间</p>

<p>CAMediaTiming还有个属性叫做repeatCount，代表动画重复的执行次数。如果duration是2，repeatCount设为3.5，那么完整的动画时长将是7秒。</p>

<p>duration和repeatCount默认都是0。这里的0仅仅代表了“默认”，也就是0.25秒和1次</p>

<p>小例子：测试duration和repeatCount</p>

<pre><code>@interface ViewController ()

@property (nonatomic, weak) IBOutlet UIView *containerView;
@property (nonatomic, weak) IBOutlet UITextField *durationField;
@property (nonatomic, weak) IBOutlet UITextField *repeatField;
@property (nonatomic, weak) IBOutlet UIButton *startButton;
@property (nonatomic, strong) CALayer *shipLayer;

@end

@implementation ViewController

- (void)viewDidLoad
{
    [super viewDidLoad];
    // 添加飞船
    self.shipLayer = [CALayer layer];
    self.shipLayer.frame = CGRectMake(0, 0, 128, 128);
    self.shipLayer.position = CGPointMake(150, 150);
    self.shipLayer.contents = (__bridge id)[UIImage imageNamed: @"Ship.png"].CGImage;
    [self.containerView.layer addSublayer:self.shipLayer];
}

- (void)setControlsEnabled:(BOOL)enabled
{
    for (UIControl *control in @[self.durationField, self.repeatField, self.startButton]) {
        control.enabled = enabled;
        control.alpha = enabled? 1.0f: 0.25f;
    }
}

- (IBAction)hideKeyboard
{
    ￼[self.durationField resignFirstResponder];
    [self.repeatField resignFirstResponder];
}

- (IBAction)start
{
    CFTimeInterval duration = [self.durationField.text doubleValue];
    float repeatCount = [self.repeatField.text floatValue];
    // 飞船旋转动画
    CABasicAnimation *animation = [CABasicAnimation animation];
    animation.keyPath = @"transform.rotation";
    animation.duration = duration;
    animation.repeatCount = repeatCount;
    animation.byValue = @(M_PI * 2);
    animation.delegate = self;
    [self.shipLayer addAnimation:animation forKey:@"rotateAnimation"];
    // 禁用控件
    [self setControlsEnabled:NO];
}

- (void)animationDidStop:(CAAnimation *)anim finished:(BOOL)flag
{
    // 打开控件
    [self setControlsEnabled:YES];
}

@end
</code></pre>

<p><img src="http://github-octopress.qiniudn.com/CoreAnimationAdvanced9.1.png" alt="Mou icon" /></p>

<p>创建重复动画的另一种方式是使用repeatDuration属性，它让动画重复一个指定的时间，而不是指定次数。</p>

<p>还可以设置autoreverses的属性（BOOL类型）在每次间隔交替循环过程中自动回放。</p>

<p>这对于播放一段连续非循环的动画很有用，例如打开一扇门，然后关上它，如下图：</p>

<p><img src="http://github-octopress.qiniudn.com/CoreAnimationAdvanced9.2.png" alt="Mou icon" /></p>

<p>小例子：使用autoreverses属性实现门的摇摆（repeatDuration设置为INFINITY，会让动画无限循环播放，设置repeatCount为INFINITY也有同样的效果。但是repeatCount和repeatDuration可能会相互冲突。）</p>

<pre><code>@interface ViewController ()

@property (nonatomic, weak) UIView *containerView;

@end

@implementation ViewController

- (void)viewDidLoad
{
    [super viewDidLoad];
    // 添加一扇门
    CALayer *doorLayer = [CALayer layer];
    doorLayer.frame = CGRectMake(0, 0, 128, 256);
    doorLayer.position = CGPointMake(150 - 64, 150);
    doorLayer.anchorPoint = CGPointMake(0, 0.5);
    doorLayer.contents = (__bridge id)[UIImage imageNamed: @"Door.png"].CGImage;
    [self.containerView.layer addSublayer:doorLayer];
    // 应用透视转换
    CATransform3D perspective = CATransform3DIdentity;
    perspective.m34 = -1.0 / 500.0;
    self.containerView.layer.sublayerTransform = perspective;
    // 应用摇摆的动画
    CABasicAnimation *animation = [CABasicAnimation animation];
    animation.keyPath = @"transform.rotation.y";
    animation.toValue = @(-M_PI_2);
    animation.duration = 2.0;
    animation.repeatDuration = INFINITY;
    animation.autoreverses = YES;
    [doorLayer addAnimation:animation forKey:nil];
}

@end
</code></pre>

<h4>9.1.2、相对时间</h4>

<p>时间都是相对的，每个动画都有它自己描述的时间，可以独立地加速，延时或者偏移。</p>

<p>beginTime指定了动画开始之前的的延迟时间。这里的延迟从动画添加到见到图层的那一刻开始测量，默认是0（即立刻执行动画）。</p>

<p>speed是一个时间的倍数，默认1.0，speed减少会减慢图层/动画的时间，speed增加会加快速度。如果2.0的速度，那么对于一个duration为1的动画，实际上在0.5秒的时候就已经完成了。</p>

<p>timeOffset和beginTime类似，但是和增加beginTime导致的延迟动画不同，增加timeOffset只是让动画快进到某一点，例如，对于一个持续1秒的动画来说，设置timeOffset为0.5意味着动画将从一半的地方开始。</p>

<p>和beginTime不同的是，timeOffset并不受speed的影响。所以如果你把speed设为2.0，把timeOffset设置为0.5，那么你的动画将从动画最后结束的地方开始，因为1秒的动画实际上被缩短到了0.5秒。然而即使使用了timeOffset让动画从结束的地方开始，它仍然播放了一个完整的时长，这个动画仅仅是循环了一圈，然后从头开始播放。</p>

<p>小例子：测试timeOffset和speed属性</p>

<pre><code>@interface ViewController ()

@property (nonatomic, weak) IBOutlet UIView *containerView;
@property (nonatomic, weak) IBOutlet UILabel *speedLabel;
@property (nonatomic, weak) IBOutlet UILabel *timeOffsetLabel;
@property (nonatomic, weak) IBOutlet UISlider *speedSlider;
@property (nonatomic, weak) IBOutlet UISlider *timeOffsetSlider;
@property (nonatomic, strong) UIBezierPath *bezierPath;
@property (nonatomic, strong) CALayer *shipLayer;

@end

@implementation ViewController

- (void)viewDidLoad
{
    [super viewDidLoad];
    // 创建路径
    self.bezierPath = [[UIBezierPath alloc] init];
    [self.bezierPath moveToPoint:CGPointMake(0, 150)];
    [self.bezierPath addCurveToPoint:CGPointMake(300, 150) controlPoint1:CGPointMake(75, 0) controlPoint2:CGPointMake(225, 300)];
    // 用CAShapeLayer绘制路径
    CAShapeLayer *pathLayer = [CAShapeLayer layer];
    pathLayer.path = self.bezierPath.CGPath;
    pathLayer.fillColor = [UIColor clearColor].CGColor;
    pathLayer.strokeColor = [UIColor redColor].CGColor;
    pathLayer.lineWidth = 3.0f;
    [self.containerView.layer addSublayer:pathLayer];
    // 添加飞船
    self.shipLayer = [CALayer layer];
    self.shipLayer.frame = CGRectMake(0, 0, 64, 64);
    self.shipLayer.position = CGPointMake(0, 150);
    self.shipLayer.contents = (__bridge id)[UIImage imageNamed: @"Ship.png"].CGImage;
    [self.containerView.layer addSublayer:self.shipLayer];
    // 设置初始值
    [self updateSliders];
}

- (IBAction)updateSliders
{
    CFTimeInterval timeOffset = self.timeOffsetSlider.value;
    self.timeOffsetLabel.text = [NSString stringWithFormat:@"%0.2f", imeOffset];
    float speed = self.speedSlider.value;
    self.speedLabel.text = [NSString stringWithFormat:@"%0.2f", speed];
}

- (IBAction)play
{
    // 创建关键帧动画
    CAKeyframeAnimation *animation = [CAKeyframeAnimation animation];
    animation.keyPath = @"position";
    animation.timeOffset = self.timeOffsetSlider.value;
    animation.speed = self.speedSlider.value;
    animation.duration = 1.0;
    animation.path = self.bezierPath.CGPath;
    animation.rotationMode = kCAAnimationRotateAuto;
    animation.removedOnCompletion = NO;
    [self.shipLayer addAnimation:animation forKey:@"slide"];
}

@end
</code></pre>

<p><img src="http://github-octopress.qiniudn.com/CoreAnimationAdvanced9.3.png" alt="Mou icon" /></p>

<h4>9.1.3、fillModel</h4>

<p>对于beginTime非0的一段动画来说，会出现一个当动画添加到图层上但什么也没发生的状态。</p>

<p>类似的，removeOnCompletion被设置为NO的动画将会在动画结束的时候仍然保持之前的状态。</p>

<p>这就产生了一个问题，当动画开始之前和动画结束之后，被设置动画的属性将会是什么值呢？</p>

<p>一种可能是属性和动画在没被添加之前保持一致，也就是在模型图层定义的值</p>

<p>另一种可能是保持动画开始之前那一帧，或者动画结束之后的那一帧。这就是所谓的填充，因为动画开始和结束的值用来填充开始之前和结束之后的时间。</p>

<p>这种行为可以被CAMediaTiming的fillMode控制。fillMode是一个NSString类型，有四种常量：</p>

<pre><code>kCAFillModeForwards 
kCAFillModeBackwards 
kCAFillModeBoth 
kCAFillModeRemoved
</code></pre>

<p>默认是kCAFillModeRemoved</p>

<p>当动画不再播放的时候就显示图层模型指定的值剩下的三种类型向前/向后/即向前又向后来填充动画状态，使得动画在开始前或者结束后仍然保持开始和结束那一刻的值。</p>

<p>这可以避免动画结束后闪变，但是，如果要解决这个问题需要把removeOnCompletion设置为NO，另外需要给动画添加一个非空的键，于是可以在不需要动画的时候把它从图层上移除。</p>

<h3>9.2、逐层时间</h3>

<p>每个动画和图层在时间上都有它自己的层级概念。</p>

<p>对每个图层调整时间将会影响到它本身和子图层的动画，但不会影响到父图层。</p>

<p>另一个相似点是所有的动画都被按照层级来排列（CAAnimationGroup）。</p>

<p>对CALayer或者CAGroupAnimation调整duration和repeatCount/repeatDuration属性并不会影响到子动画。</p>

<p>但是beginTime，timeOffset和speed属性将会影响到子动画。</p>

<p>然而在层级关系中，beginTime指定了父图层开始动画（或者组合关系中的父动画）和对象将要开始自己动画之间的偏移。</p>

<p>调整CALayer和CAGroupAnimation的speed属性将会对动画以及子动画速度应用一个缩放的因子。</p>

<h4>9.2.1、全局时间和本地时间</h4>

<p>CoreAnimation有一个全局时间的概念，也就是所谓的马赫时间（“马赫”实际上是iOS和Mac OS系统内核的命名）。</p>

<p>马赫时间在设备上所有进程都是全局的(在不同设备上不是),可以使用CACurrentMediaTime函数来访问马赫时间：</p>

<pre><code>CFTimeInterval time = CACurrentMediaTime();
</code></pre>

<p>这个函数返回的值其实不重要（它返回了设备自从上次启动后的秒数），但是可以对动画的时间测量提供了一个相对值。</p>

<p>当设备休眠的时候马赫时间会暂停，也就是所有的CAAnimations（基于马赫时间）同样也会暂停。</p>

<p>因此马赫时间对长时间测量并不有用。</p>

<p>比如用CACurrentMediaTime去更新一个实时闹钟就不合适了。（可以用[NSDate date]）。</p>

<p>每个CALayer和CAAnimation实例都有自己本地时间的概念，是根据父图层/动画层级关系中的beginTime，timeOffset和speed属性计算。</p>

<p>就和转换不同图层之间坐标关系一样，CALayer同样也提供了方法来转换不同图层之间的本地时间。如下：</p>

<pre><code>- (CFTimeInterval)convertTime:(CFTimeInterval)t fromLayer:(CALayer *)l; 
- (CFTimeInterval)convertTime:(CFTimeInterval)t toLayer:(CALayer *)l;
</code></pre>

<p>当用来同步不同图层之间有不同的speed，timeOffset和beginTime的动画，这些方法会很有用。</p>

<h4>9.2.2、暂停, 回退和快进</h4>

<p>当动画speed属性为0时，可以暂停动画，但是不能对正在进行的动画使用这个属性。</p>

<p>给图层添加一个CAAnimation实际上是给动画对象做了一个不可变的拷贝，所以对原始动画对象属性的改变对真实的动画并没有作用。</p>

<p>而且直接用-animationForKey:来检索图层正在进行的动画可以返回正确的动画对象，但是修改它的属性将会抛出异常。</p>

<p>如果移除图层正在进行的动画，图层将会<code>急速</code>返回动画之前的状态。但如果在动画移除之前拷贝呈现图层到模型图层，动画将会看起来暂停在那里。但是不好的地方在于之后就不能再恢复动画了。</p>

<p>有一个简单的方法是利用CAMediaTiming来暂停图层本身。</p>

<p>如果把图层的speed设置成0，它会暂停任何添加到图层上的动画。</p>

<p>类似的，设置speed大于1.0将会快进，设置成一个负值将会倒回动画。</p>

<p>通过增加主窗口图层的speed，可以暂停整个应用程序的动画。</p>

<p>可以在app delegate设置如下进行验证：</p>

<pre><code>self.window.layer.speed = 100;
</code></pre>

<p>你也可以通过这种方式来减速，但其实也可以在模拟器通过切换慢速动画来实现。</p>

<h3>9.3、手动动画</h3>

<p>timeOffset可以让你手动控制动画进程，通过设置speed为0，可以禁用动画的自动播放，然后来使用timeOffset来来回显示动画序列。</p>

<p>这可以使得运用手势来手动控制动画变得很简单。</p>

<p>小例子：通过触摸手势手动控制动画</p>

<pre><code>@interface ViewController ()

@property (nonatomic, weak) UIView *containerView;
@property (nonatomic, strong) CALayer *doorLayer;

@end

@implementation ViewController

- (void)viewDidLoad
{
    [super viewDidLoad];
    // 添加个门
    self.doorLayer = [CALayer layer];
    self.doorLayer.frame = CGRectMake(0, 0, 128, 256);
    self.doorLayer.position = CGPointMake(150 - 64, 150);
    self.doorLayer.anchorPoint = CGPointMake(0, 0.5);
    self.doorLayer.contents = (__bridge id)[UIImage imageNamed:@"Door.png"].CGImage;
    [self.containerView.layer addSublayer:self.doorLayer];
    // 应用透视变换
    CATransform3D perspective = CATransform3DIdentity;
    perspective.m34 = -1.0 / 500.0;
    self.containerView.layer.sublayerTransform = perspective;
    // 添加摇摆门用的手势
    UIPanGestureRecognizer *pan = [[UIPanGestureRecognizer alloc] init];
    [pan addTarget:self action:@selector(pan:)];
    [self.view addGestureRecognizer:pan];
    // 暂停所有图层动画
    self.doorLayer.speed = 0.0;
    // 应用摇摆动画
    CABasicAnimation *animation = [CABasicAnimation animation];
    animation.keyPath = @"transform.rotation.y";
    animation.toValue = @(-M_PI_2);
    animation.duration = 1.0;
    [self.doorLayer addAnimation:animation forKey:nil];
}

- (void)pan:(UIPanGestureRecognizer *)pan
{
    // 通过手势获得水平部分
    CGFloat x = [pan translationInView:self.view].x;
    // 转换成动画进度
    x /= 200.0f;
    // 更新timeOffset
    CFTimeInterval timeOffset = self.doorLayer.timeOffset;
    timeOffset = MIN(0.999, MAX(0.0, timeOffset - x));
    self.doorLayer.timeOffset = timeOffset;
    // 重置手势
    [pan setTranslation:CGPointZero inView:self.view];
}

@end
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Core Animation Advanced Technique 学习笔记(7)]]></title>
    <link href="http://joylong.github.io/blog/2014/09/07/core-animation-advanced-technique-7/"/>
    <updated>2014-09-07T09:25:40+08:00</updated>
    <id>http://joylong.github.io/blog/2014/09/07/core-animation-advanced-technique-7</id>
    <content type="html"><![CDATA[<h1>第二部分：运动中的设置</h1>

<h2>8、显式动画（Implicit Animations）</h2>

<h3>8.1、属性动画</h3>

<p>属性动画作用于图层的某个单一属性，并指定了这个属性的一个目标值，或者动画进行过程中一连串关键点的值。</p>

<p>属性动画分为两种：基础动画和关键帧动画。</p>

<h4>8.1.1、基础动画</h4>

<p>动画其实就是一段时间内发生的改变，最简单的形式就是从一个值改变到另一个值，这也是CABasicAnimation最主要的功能。</p>

<p>CABasicAnimation是CAPropertyAnimation的一个子类，CAPropertyAnimation同时也是Core Animation所有动画类型的抽象基类。</p>

<p>作为一个抽象类，CAAnimation本身并没有做多少工作，它提供了一个计时函数，一个委托（用于反映动画状态）以及一个removedOnCompletion的布尔值，用于标识动画是否该在结束后自动释放（默认YES，为了防止内存泄露）。</p>

<p>CAAnimation同时实现了一些协议，包括CAAction（允许CAAnimation的子类可以提供图层行为），以及CAMediaTiming。</p>

<p>CAPropertyAnimation通过指定动画的keyPath作用到某个单一属性上，CAAnimation通常应用于一个指定的CALayer，于是这里指的也就是一个图层的keyPath了。实际上它是一个关键路径，而不仅仅是属性的名称，这意味着动画不仅可以作用于图层本身的属性，而且还包含了它的子成员的属性，甚至是一些虚拟的属性。</p>

<p>CABasicAnimation继承于CAPropertyAnimation，并添加了如下属性：</p>

<pre><code>id fromValue  // 动画开始之前属性的值
id toValue    // 动画结束之后属性的值
id byValue    // 执行过程中改变的值
</code></pre>

<p>它们被定义成id类型而不是一些具体的类型是因为属性动画可以用作很多不同种的属性类型，包括数字类型，矢量，变换矩阵，甚至是颜色或者图片。</p>

<p>id类型可以包含任意由NSObject派生的对象，加入要对一些不直接从NSObject继承的属性类型做动画，则意味着需要把这些值用一个对象来封装，或者强转成一个对象，就像某些功能和Objective-C对象类似的Core Foundation类型。</p>

<p>小例子：用于CAPropertyAnimation的一些类型转换</p>

<table>
<thead>
<tr>
<th>类型 </th>
<th> 对象类型 </th>
<th> 转换的代码例子</th>
</tr>
</thead>
<tbody>
<tr>
<td>CGFloat </td>
<td> NSNumber  </td>
<td> id obj = @(float);</td>
</tr>
<tr>
<td>CGPoint </td>
<td> NSValue  </td>
<td> id obj = [NSValue valueWithCGPoint:point);</td>
</tr>
<tr>
<td>CGSize </td>
<td> NSValue  </td>
<td> id obj = [NSValue valueWithCGSize:size);</td>
</tr>
<tr>
<td>CGRect </td>
<td> NSValue  </td>
<td> id obj = [NSValue valueWithCGRect:rect);</td>
</tr>
<tr>
<td>CATransform3D </td>
<td> NSValue  </td>
<td> id obj = [NSValue valueWithCATransform3D:transform);</td>
</tr>
<tr>
<td>CGImageRef </td>
<td> id  </td>
<td> id obj = (__bridge id)imageRef;</td>
</tr>
<tr>
<td>CGColorRef </td>
<td> id  </td>
<td> id obj = (__bridge id)colorRef;</td>
</tr>
</tbody>
</table>


<p>fromValue，toValue和byValue属性可以用很多种方式来组合，但为了防止冲突，不能一次性同时指定这三个值。</p>

<p>例如，如果指定了fromValue等于2，toValue等于4，byValue等于3，那么Core Animation就不知道结果到底是4（toValue）还是5（fromValue + byValue）了。</p>

<p>他们的用法在CABasicAnimation头文件中已经描述的很清楚了，所以在这里就不重复了。总的说来，就是只需要指定toValue或者byValue，剩下的值都可以通过上下文自动计算出来。</p>

<p>小例子：通过CABasicAnimation来设置图层背景色</p>

<pre><code>@interface ViewController ()

@property (nonatomic, weak) IBOutlet UIView *layerView;
@property (nonatomic, strong) IBOutlet CALayer *colorLayer;

@end

@implementation ViewController

- (void)viewDidLoad
{
    [super viewDidLoad];
    // 创建子图层
    self.colorLayer = [CALayer layer];
    self.colorLayer.frame = CGRectMake(50.0f, 50.0f, 100.0f, 100.0f);
    self.colorLayer.backgroundColor = [UIColor blueColor].CGColor;
    // 添加到视图上
    [self.layerView.layer addSublayer:self.colorLayer];
}

- (IBAction)changeColor
{
    ￼// 创建一个新的随机颜色
    CGFloat red = arc4random() / (CGFloat)INT_MAX;
    CGFloat green = arc4random() / (CGFloat)INT_MAX;
    CGFloat blue = arc4random() / (CGFloat)INT_MAX;
    UIColor *color = [UIColor colorWithRed:red green:green blue:blue alpha:1.0];
    // 创建一个基本动画
    CABasicAnimation *animation = [CABasicAnimation animation];
    animation.keyPath = @"backgroundColor";
    animation.toValue = (__bridge id)color.CGColor;
    // 在图层上设置动画
    [self.colorLayer addAnimation:animation forKey:nil];
}

@end
</code></pre>

<p>运行程序，结果有点差强人意，点击按钮，的确可以使图层动画过渡到一个新的颜色，然动画结束之后又立刻变回原始值。</p>

<p>这是因为动画并没有改变图层的模型，而只是展现。一旦动画结束并从图层上移除之后，图层就立刻恢复到之前定义的外观状态。我们从没改变过backgroundColor属性，所以图层就返回到原始的颜色。</p>

<p>当之前在使用隐式动画的时候，实际上它就是用例子中CABasicAnimation来实现的。但是在那个例子中，我们通过设置属性来打开动画。在这里我们做了相同的动画，但是并没有设置任何属性的值（这也是为什么会立刻变回初始状态的原因）。</p>

<p>把动画设置成一个图层的行为（然后通过改变属性值来启动动画）是到目前为止同步属性值和动画状态最简单的方式了。</p>

<p>假设因为UIView关联的图层不能这么做动画，那么有两种可以更新属性值的方式：</p>

<pre><code>在动画开始之前或者动画结束之后。
</code></pre>

<p>动画之前改变属性的值是最简单的办法，但这意味着我们不能使用fromValue这么好的特性了，而且要手动将fromValue设置成图层当前的值。</p>

<p>于是在动画创建之前插入如下代码，就可以解决问题了</p>

<pre><code>animation.fromValue = (__bridge id)self.colorLayer.backgroundColor; 
self.colorLayer.backgroundColor = color.CGColor;
</code></pre>

<p>这的确是可行的，但还是有些问题，如果这里已经正在进行一段动画，我们需要从表现图层那里去获得fromValue，而不是模型图层。</p>

<p>此外，由于图层并不是UIView关联的图层，需要用CATransaction来禁用隐式动画行为，否则默认的图层行为会干扰我们的显式动画</p>

<p>更新之后的代码如下：</p>

<pre><code>CALayer *layer = self.colorLayer.presentationLayer ?:
self.colorLayer;
animation.fromValue = (__bridge id)layer.backgroundColor;
[CATransaction begin];
[CATransaction setDisableActions:YES];
self.colorLayer.backgroundColor = color.CGColor;
[CATransaction commit];
</code></pre>

<p>小例子：抽象出一个立刻恢复到原始状态的可复用函数</p>

<pre><code>- (void)applyBasicAnimation:(CABasicAnimation *)animation toLayer:(CALayer *)layer
￼{

    // 设置fromValue
    animation.fromValue = [layer.presentationLayer ?: layer valueForKeyPath:animation.keyPath];
    // 更新属性，注：只有toValue不为nil时这个值才有意义
    [CATransaction begin];
    [CATransaction setDisableActions:YES];
    [layer setValue:animation.toValue forKeyPath:animation.keyPath];
    [CATransaction commit];
    // 图层上应用动画
    [layer addAnimation:animation forKey:nil];
}

- (IBAction)changeColor
{
    // 创建新的随机色
    CGFloat red = arc4random() / (CGFloat)INT_MAX;
    CGFloat green = arc4random() / (CGFloat)INT_MAX;
    CGFloat blue = arc4random() / (CGFloat)INT_MAX;
    UIColor *color = [UIColor colorWithRed:red green:green blue:blue alpha:1.0];
    // 创建基础动画
    CABasicAnimation *animation = [CABasicAnimation animation];
    animation.keyPath = @"backgroundColor";
    animation.toValue = (__bridge id)color.CGColor;
    // 应用动画
    [self applyBasicAnimation:animation toLayer:self.colorLayer];
}
</code></pre>

<p>这种简单的实现方式通过toValue而不是byValue来处理动画，这已经是朝更好的解决方案迈出一大步了。你可以把它添加给CALaye作为一个分类，以方便更好地使用。</p>

<p>如果不在动画开始之前去更新目标属性，那么就只能在动画完全结束或者取消的时候更新它。这意味着我们需要精准地在动画结束之后，图层返回到原始值之前更新属性。那么该如何找到这个点呢？</p>

<h4>8.1.2、CAAnimationDelegate</h4>

<p>使用隐式动画时，可以在CATransaction的完成块中检测到动画完成。</p>

<p>但是这种方式并不适用于显式动画，因为这里的动画和事务并没太多关联。</p>

<p>因此想要知道一个显式动画在何时结束，需要实现CAAnimationDelegate协议。</p>

<p>CAAnimationDelegate在任何头文件中都找不到，但是可以在CAAnimation头文件或者苹果开发者文档中找到相关函数。</p>

<p>小例子：动画完成之后修改图层的背景色（当更新属性的时候，我们需要设置一个新的事务，并且禁用图层行为。否则动画会发生两次，一个是因为显式的CABasicAnimation，另一次是因为隐式动画）</p>

<pre><code>@implementation ViewController

- (void)viewDidLoad
{
    [super viewDidLoad];
    // 创建子图层
    self.colorLayer = [CALayer layer];
    self.colorLayer.frame = CGRectMake(50.0f, 50.0f, 100.0f, 100.0f);
    self.colorLayer.backgroundColor = [UIColor blueColor].CGColor;
    // 添加到视图中
    [self.layerView.layer addSublayer:self.colorLayer];
}

- (IBAction)changeColor
{
    // 创建新的随机色
    CGFloat red = arc4random() / (CGFloat)INT_MAX;
    CGFloat green = arc4random() / (CGFloat)INT_MAX;
    CGFloat blue = arc4random() / (CGFloat)INT_MAX;
    UIColor *color = [UIColor colorWithRed:red green:green blue:blue alpha:1.0];
    // 创建基础动画
    CABasicAnimation *animation = [CABasicAnimation animation];
    animation.keyPath = @"backgroundColor";
    animation.toValue = (__bridge id)color.CGColor;
    animation.delegate = self;
    // 在图层上应用图层
    [self.colorLayer addAnimation:animation forKey:nil];
}

- (void)animationDidStop:(CABasicAnimation *)anim finished:(BOOL)flag
{
    // 设置backgroundColor属性来匹配动画toValue
    [CATransaction begin];
    [CATransaction setDisableActions:YES];
    self.colorLayer.backgroundColor = (__bridge CGColorRef)anim.toValue;
    [CATransaction commit];
}

@end
</code></pre>

<p>对CAAnimation而言，当有多个动画的时候，回调方法中无法区分哪个动画。</p>

<p>之前写过一个例子，通过简单地每秒更新指针的角度来实现一个钟，但如果指针动态地转向新的位置会更加真实。</p>

<p>这个效果不能通过隐式动画来实现，因为这些指针都是UIView的实例，所以图层的隐式动画都被禁用了。</p>

<p>我们可以通过UIView的动画方法来实现。但如果想更好地控制动画时间，使用显式动画会更好。</p>

<p>而使用CABasicAnimation来做动画可能会更加复杂，因为我们需要在-animationDidStop:finished:中检测指针状态（用于设置结束的位置）。</p>

<p>动画本身会作为一个参数传入委托的方法，很多人认为可以通过这个参数来比较，然后区分是什么动画，但实际上并不起作用，因为委托传入的动画参数是原始值的一个深拷贝，从而不是同一个值。</p>

<p>当使用-addAnimation:forKey:把动画添加到图层，这里有一个到目前为止我们都设置为nil的key参数。这里的键是-animationForKey:方法找到对应动画的唯一标识符，而当前动画的所有键都可以用animationKeys获取。如果我们对每个动画都关联一个唯一的键，就可以对每个图层循环所有键，然后调用-animationForKey:来比对结果。尽管这不是一个优雅的实现。</p>

<p>幸运的是，还有一种更加简单的方法。像所有的NSObject子类一样，CAAnimation实现了KVC协议，于是你可以用-setValue:forKey:和-valueForKey:方法来存取属性。</p>

<pre><code>但是CAAnimation有一个不同的性能：它更像一个NSDictionary，可以让你随意设置键值对，即使和你使用的动画类所声明的属性并不匹配。
</code></pre>

<p>这意味着你可以用任意类型标记动画。在这里，我们给UIView类型的指针添加的动画，所以可以简单地判断动画到底属于哪个视图，然后在委托方法中用这个信息正确地更新钟的指针</p>

<p>小例子：使用KVC标记动画</p>

<pre><code>@interface ViewController ()

@property (nonatomic, weak) IBOutlet UIImageView *hourHand;
@property (nonatomic, weak) IBOutlet UIImageView *minuteHand;
@property (nonatomic, weak) IBOutlet UIImageView *secondHand;
@property (nonatomic, weak) NSTimer *timer;

@end

@implementation ViewController

- (void)viewDidLoad
{
    [super viewDidLoad];
    // 调整锚点
    self.secondHand.layer.anchorPoint = CGPointMake(0.5f, 0.9f);
    self.minuteHand.layer.anchorPoint = CGPointMake(0.5f, 0.9f);
    self.hourHand.layer.anchorPoint = CGPointMake(0.5f, 0.9f);
    // 开始计时器
    self.timer = [NSTimer scheduledTimerWithTimeInterval:1.0 target:self selector:@selector(tick) userInfo:nil repeats:YES];
    // 设置初始位置
    [self updateHandsAnimated:NO];
}

- (void)tick
{
    [self updateHandsAnimated:YES];
}

- (void)updateHandsAnimated:(BOOL)animated
{
    // 转换时间格式
    NSCalendar *calendar = [[NSCalendar alloc] initWithCalendarIdentifier:NSGregorianCalendar];
    NSUInteger units = NSHourCalendarUnit | NSMinuteCalendarUnit | NSSecondCalendarUnit;
    NSDateComponents *components = [calendar components:units fromDate:[NSDate date]];
    // 计算小时角度
    CGFloat hourAngle = (components.hour / 12.0) * M_PI * 2.0;
    // 计算分钟角度
    CGFloat minuteAngle = (components.minute / 60.0) * M_PI * 2.0;
    // 计算秒针角度
    CGFloat secondAngle = (components.second / 60.0) * M_PI * 2.0;
    // 旋转
    [self setAngle:hourAngle forHand:self.hourHand animated:animated];
    [self setAngle:minuteAngle forHand:self.minuteHand animated:animated];
    [self setAngle:secondAngle forHand:self.secondHand animated:animated];
}

- (void)setAngle:(CGFloat)angle forHand:(UIView *)handView animated:(BOOL)animated
{
    // 生成transform
    CATransform3D transform = CATransform3DMakeRotation(angle, 0, 0, 1);
    if (animated) {
        // 创建动画
        CABasicAnimation *animation = [CABasicAnimation animation];
        [self updateHandsAnimated:NO];
        animation.keyPath = @"transform";
        animation.toValue = [NSValue valueWithCATransform3D:transform];
        animation.duration = 0.5;
        animation.delegate = self;
        [animation setValue:handView forKey:@"handView"];
        [handView.layer addAnimation:animation forKey:nil];
    } else {
        // 直接设置transform
        handView.layer.transform = transform;
    }
}

- (void)animationDidStop:(CABasicAnimation *)anim finished:(BOOL)flag
{
    // 设置最终位置
    UIView *handView = [anim valueForKey:@"handView"];
    handView.layer.transform = [anim.toValue CATransform3DValue];
}
</code></pre>

<p>现在这个例子可以成功识别出每个图层停止动画的时间，更新它的变换到一个新值，但是这个代码在模拟器上运行正常，在设备上运行时在-animationDidStop:finished:委托方法调用之前，指针会迅速返回到原始值。</p>

<p>问题在于回调方法在动画完成之前已经被调用了，而且不能保证发生在属性动画返回初始状态之前。</p>

<p>这个问题可以用fillMode属性来解决。</p>

<h4>8.1.3、关键帧动画</h4>

<p>CAKeyframeAnimation是另一种UIKit没有暴露但功能强大的类。</p>

<p>和CABasicAnimation类似，CAKeyframeAnimation同样是CAPropertyAnimation的一个子类，它依然作用于单一属性，但和CABasicAnimation不同之处在于，它并不限制于设置一个起始和结束的值，而是可以根据一连串随意的值来做动画。</p>

<p>CAKeyframeAnimation提供了关键节点的帧，然后Core Animation在非关键位置对每帧之间进行自动处理。</p>

<p>小例子：使用CAKeyframeAnimation应用一系列颜色的变化</p>

<pre><code>- (IBAction)changeColor
{
    // 创建一个关键帧动画
    CAKeyframeAnimation *animation = [CAKeyframeAnimation animation];
    animation.keyPath = @"backgroundColor";
    animation.duration = 2.0;
    animation.values = @[
                     (__bridge id)[UIColor blueColor].CGColor,
                     (__bridge id)[UIColor redColor].CGColor,
                     (__bridge id)[UIColor greenColor].CGColor,
                     (__bridge id)[UIColor blueColor].CGColor ];
    // 应用动画到图层
    [self.colorLayer addAnimation:animation forKey:nil];
}
</code></pre>

<p>要注意：动画序列中开始和结束的颜色都是蓝色，这是因为CAKeyframeAnimation并不会自动把当前值作为第一帧（就像CABasicAnimation那样把fromValue设为nil）。</p>

<p>动画会在开始的时候突变到第一帧的值，然后在动画结束的时候突然恢复到原始的值。</p>

<p>所以为了动画的平滑特性，我们需要开始和结束的关键帧来匹配当前属性的值。</p>

<p>当然可以创建一个结束和开始值不同的动画，那样的话就需要在动画启动之前手动更新属性和最后一帧的值保持一致。</p>

<p>我们用duration属性把动画时间从默认的0.25秒增加到2秒，以便于动画做的不那么快。</p>

<p>运行这段代码会发现颜色不断循环，但效果有些奇怪。这是因为动画以一个恒定的步调在运行。当在每个动画之间过渡的时候并没有减速，这就产生了一个略微奇怪的效果，为了让动画看起来更自然，需要调整一下缓冲。</p>

<p>提供一个数组的值就可以按照颜色变化做动画，但是CAKeyframeAnimation有另一种方式去指定动画，就是使用CGPath类型的path属性来定义运动的序列来绘制动画。</p>

<p>以一个宇宙飞船沿着一个简单曲线的实例来举例。</p>

<p>为了创建路径，我们需要使用一个三次贝塞尔曲线，它是一种使用开始点，结束点和另外两个控制点来定义形状的曲线，可以通过使用一个基于C的Core Graphics绘图指令来创建，但是用UIKit提供的UIBezierPath类会更简单。</p>

<p>这次用CAShapeLayer来绘制曲线。绘制完CGPath之后，我们用它来创建一个CAKeyframeAnimation，然后应用到我们的宇宙飞船。</p>

<p>小例子：沿着一个贝塞尔曲线对图层做动画</p>

<pre><code>@interface ViewController ()

@property (nonatomic, weak) IBOutlet UIView *containerView;

@end

@implementation ViewController

- (void)viewDidLoad
{
    [super viewDidLoad];
    // 创建path
    UIBezierPath *bezierPath = [[UIBezierPath alloc] init];
    [bezierPath moveToPoint:CGPointMake(0, 150)];
    [bezierPath addCurveToPoint:CGPointMake(300, 150) controlPoint1:CGPointMake(75, 0) controlPoint2:CGPointMake(225, 300)];
    // 用CAShapeLayer绘制path
    CAShapeLayer *pathLayer = [CAShapeLayer layer];
    pathLayer.path = bezierPath.CGPath;
    pathLayer.fillColor = [UIColor clearColor].CGColor;
    pathLayer.strokeColor = [UIColor redColor].CGColor;
    pathLayer.lineWidth = 3.0f;
    [self.containerView.layer addSublayer:pathLayer];
    // 添加飞船
    CALayer *shipLayer = [CALayer layer];
    shipLayer.frame = CGRectMake(0, 0, 64, 64);
    shipLayer.position = CGPointMake(0, 150);
    shipLayer.contents = (__bridge id)[UIImage imageNamed: @"Ship.png"].CGImage;
    [self.containerView.layer addSublayer:shipLayer];
    // 创建关键帧动画
    CAKeyframeAnimation *animation = [CAKeyframeAnimation animation];
    animation.keyPath = @"position";
    animation.duration = 4.0;
    animation.path = bezierPath.CGPath;
    [shipLayer addAnimation:animation forKey:nil];
}

@end
</code></pre>

<p><img src="http://github-octopress.qiniudn.com/CoreAnimationAdvanced8.1.png" alt="Mou icon" /></p>

<p>运行代码，会发现飞船的动画有些不太真实，这是因为当它运动的时候永远指向右边，而不是指向曲线切线的方向。有种方法是调整它的affineTransform来对运动方向做动画，但很可能和其它的动画冲突。</p>

<p>还有一种更加合适的方式就是使用CAKeyFrameAnimation的rotationMode属性。设置它为常量kCAAnimationRotateAuto，图层将会根据曲线的切线自动旋转。</p>

<p>小例子：通过rotationMode自动对齐图层到曲线</p>

<pre><code>- (void)viewDidLoad
{
    [super viewDidLoad];
    // 创建路径
    ...
    // 创建关键帧动画
    CAKeyframeAnimation *animation = [CAKeyframeAnimation animation];
    animation.keyPath = @"position";
    animation.duration = 4.0;
    animation.path = bezierPath.CGPath;
    animation.rotationMode = kCAAnimationRotateAuto;
    [shipLayer addAnimation:animation forKey:nil];
}
</code></pre>

<p><img src="http://github-octopress.qiniudn.com/CoreAnimationAdvanced8.2.png" alt="Mou icon" /></p>

<h4>8.1.4、虚拟属性</h4>

<p>如果想要对一个物体做旋转的动画，那就需要作用于transform属性，因为CALayer没有显式提供角度或者方向之类的属性</p>

<p>小例子：用transform属性对图层做动画</p>

<pre><code>@interface ViewController ()

@property (nonatomic, weak) IBOutlet UIView *containerView;

@end

@implementation ViewController

- (void)viewDidLoad
{
    [super viewDidLoad];
    // 添加飞船
    CALayer *shipLayer = [CALayer layer];
    shipLayer.frame = CGRectMake(0, 0, 128, 128);
    shipLayer.position = CGPointMake(150, 150);
    shipLayer.contents = (__bridge id)[UIImage imageNamed: @"Ship.png"].CGImage;
    [self.containerView.layer addSublayer:shipLayer];
    // 飞船旋转
    CABasicAnimation *animation = [CABasicAnimation animation];
    animation.keyPath = @"transform";
    animation.duration = 2.0;
    animation.toValue = [NSValue valueWithCATransform3D: CATransform3DMakeRotation(M_PI, 0, 0, 1)];
    [shipLayer addAnimation:animation forKey:nil];
}

@end
</code></pre>

<p>如果我们把旋转的值从M_PI（180度）调整到2 * M_PI（360度），然后运行程序，会发现这时候飞船完全不动了。这是因为这里的矩阵做了一次360度的旋转，和做了0度是一样的，所以最后的值根本没变。</p>

<p>现在继续使用M_PI，但这次用byValue而不是toValue。也许你会认为这和设置toValue结果一样，因为0 + 90度 == 90度，但实际上飞船的图片变大了，并没有做任何旋转，这是因为变换矩阵不能像角度值那样叠加。</p>

<p>如果需要独立于角度之外单独对平移或者缩放做动画呢？由于都需要我们来修改transform属性，实时地重新计算每个时间点的每个变换效果，然后根据这些创建一个复杂的关键帧动画，这一切都是为了对图层的一个独立做一个简单的动画。</p>

<p>幸运的是，有一个更好的解决方案：</p>

<p>为了旋转图层，我们可以对transform.rotation关键路径应用动画，而不是transform本身。</p>

<p>小例子：对虚拟的transform.rotation属性做动画</p>

<pre><code>@interface ViewController ()

@property (nonatomic, weak) IBOutlet UIView *containerView;

@end

@implementation ViewController

- (void)viewDidLoad
{
    [super viewDidLoad];
    // 添加飞船
    CALayer *shipLayer = [CALayer layer];
    shipLayer.frame = CGRectMake(0, 0, 128, 128);
    shipLayer.position = CGPointMake(150, 150);
    shipLayer.contents = (__bridge id)[UIImage imageNamed: @"Ship.png"].CGImage;
    [self.containerView.layer addSublayer:shipLayer];
    // 飞船旋转
    CABasicAnimation *animation = [CABasicAnimation animation];
    animation.keyPath = @"transform.rotation";
    animation.duration = 2.0;
    animation.byValue = @(M_PI * 2);
    [shipLayer addAnimation:animation forKey:nil];
}

@end
</code></pre>

<p>运行效果非常好。</p>

<p>用transform.rotation而不是transform做动画的好处如下：</p>

<ul>
<li><p>我们可以不通过关键帧一步旋转多于180度的动画。</p></li>
<li><p>可以用相对值而不是绝对值旋转（设置byValue而不是toValue）。</p></li>
<li><p>可以不用创建CATransform3D，而是使用一个简单的数值来指定角度。</p></li>
<li><p>不会和transform.position或者transform.scale冲突（同样是使用关键路径来做独立的动画属性）。</p></li>
</ul>


<p>transform.rotation属性其实并不存在。因为CATransform3D实际上是一个结构体，也没有符合KVC相关属性，transform.rotation实际上是CALayer用于处理动画变换的一个虚拟属性。</p>

<p>你不可以直接设置transform.rotation或者transform.scale，他们不能被直接使用。当你对他们做动画时，Core Animation自动地根据通过CAValueFunction来计算的值来更新transform属性。</p>

<p>CAValueFunction用于把我们赋给transform.rotation的简单浮点值转换成真正的用于摆放图层的CATransform3D矩阵值。你可以通过设置CAPropertyAnimation的valueFunction属性来改变，于是你设置的函数将会覆盖默认的函数。</p>

<p>CAValueFunction看起来似乎是对那些不能简单相加的属性（例如变换矩阵）做动画的非常有用的机制，但由于CAValueFunction的实现细节是私有的，所以目前不能通过继承它来自定义。赋值只能通过使用苹果目前已近提供的常量。</p>

<h3>8.2、动画组</h3>

<p>CABasicAnimation和CAKeyframeAnimation仅仅作用于单独的属性</p>

<p>而CAAnimationGroup可以把这些动画组合在一起。</p>

<p>CAAnimationGroup是另一个继承于CAAnimation的子类，它添加了一个animations数组的属性，用来组合别的动画。</p>

<p>小例子：组合关键帧动画和基础动画</p>

<pre><code>- (void)viewDidLoad
{
    [super viewDidLoad];
    // 创建路径
    UIBezierPath *bezierPath = [[UIBezierPath alloc] init];
    [bezierPath moveToPoint:CGPointMake(0, 150)];
    [bezierPath addCurveToPoint:CGPointMake(300, 150) controlPoint1:CGPointMake(75, 0) controlPoint2:CGPointMake(225, 300)];
    // 用CAShapeLayer绘制路径
    CAShapeLayer *pathLayer = [CAShapeLayer layer];
    pathLayer.path = bezierPath.CGPath;
    pathLayer.fillColor = [UIColor clearColor].CGColor;
    pathLayer.strokeColor = [UIColor redColor].CGColor;
    pathLayer.lineWidth = 3.0f;
    [self.containerView.layer addSublayer:pathLayer];
    // 添加带色图层
    CALayer *colorLayer = [CALayer layer];
    colorLayer.frame = CGRectMake(0, 0, 64, 64);
    colorLayer.position = CGPointMake(0, 150);
    colorLayer.backgroundColor = [UIColor greenColor].CGColor;
    [self.containerView.layer addSublayer:colorLayer];
    // 创建位置动画
    CAKeyframeAnimation *animation1 = [CAKeyframeAnimation animation];
    animation1.keyPath = @"position";
    animation1.path = bezierPath.CGPath;
    animation1.rotationMode = kCAAnimationRotateAuto;
    // 创建颜色动画
    CABasicAnimation *animation2 = [CABasicAnimation animation];
    animation2.keyPath = @"backgroundColor";
    animation2.toValue = (__bridge id)[UIColor redColor].CGColor;
    // 创建动画组
    CAAnimationGroup *groupAnimation = [CAAnimationGroup animation];
    groupAnimation.animations = @[animation1, animation2]; 
    groupAnimation.duration = 4.0;
    // 添加到图层
    [colorLayer addAnimation:groupAnimation forKey:nil];
}
</code></pre>

<p><img src="http://github-octopress.qiniudn.com/CoreAnimationAdvanced8.3.png" alt="Mou icon" /></p>

<h3>8.3、过渡</h3>

<p>属性动画只对图层的可动画属性起作用，所以如果要改变一个不能动画的属性（比如图片），或者从层级关系中添加或者移除图层，属性动画将不起作用。</p>

<p>于是就有了过渡。过渡并不像属性动画那样平滑地在两个值之间做动画，而是影响到整个图层的变化。过渡动画首先展示之前的图层外观，然后通过一个交换过渡到新的外观。</p>

<p>为了创建一个过渡动画，我们将使用CATransition，CATransition同样是另一个CAAnimation的子类，和别的子类不同，CAAnimation有一个type和subtype来标识变换效果。type属性是一个NSString类型，可以被设置成如下类型：</p>

<pre><code>kCATransitionFade  // 默认类型，当你在改变图层属性之后，就创建了一个平滑的淡入淡出效果
kCATransitionMoveIn // 顶部滑动进入，但不像推送动画那样把老图层推走
kCATransitionPush  // 创建了一个新图层，从边缘的一侧滑动进来，把旧图层从另一侧推出去
kCATransitionReveal // 把原始的图层滑动出去来显示新的外观，而不是把新的图层滑动进入
</code></pre>

<p>后面三种类型都有一个默认的动画方向，即都从左侧滑入</p>

<p>但是你可以通过subtype来控制它们的方向，提供了如下四种类型：</p>

<pre><code>kCATransitionFromRight 
kCATransitionFromLeft 
kCATransitionFromTop 
kCATransitionFromBottom
</code></pre>

<p>小例子：使用CATransition来对UIImageView做动画</p>

<pre><code>@interface ViewController ()

@property (nonatomic, weak) IBOutlet UIImageView *imageView;
@property (nonatomic, copy) NSArray *images;

@end

@implementation ViewController

- (void)viewDidLoad
{
    [super viewDidLoad];
    //set up images
    self.images = @[[UIImage imageNamed:@"Anchor.png"],
                    [UIImage imageNamed:@"Cone.png"],
                    [UIImage imageNamed:@"Igloo.png"],
                    [UIImage imageNamed:@"Spaceship.png"]];
}


- (IBAction)switchImage
{
    // 设置变换类型
    CATransition *transition = [CATransition animation];
    transition.type = kCATransitionFade;
    // 应用变换到imageView的寄宿图层上
    [self.imageView.layer addAnimation:transition forKey:nil];
    // 循环到下一张
    UIImage *currentImage = self.imageView.image;
    NSUInteger index = [self.images indexOfObject:currentImage];
    index = (index + 1) % [self.images count];
    self.imageView.image = self.images[index];
}

@end
</code></pre>

<p>过渡动画和之前的属性动画或者动画组添加到图层上的方式一致，都是通过-addAnimation:forKey:方法。</p>

<p>但是和属性动画不同的是，对指定的图层一次只能使用一次CATransition，因此，无论你对动画的键设置什么值，过渡动画都会对它的键设置成“transition”，也就是常量kCATransition。</p>

<p><img src="http://github-octopress.qiniudn.com/CoreAnimationAdvanced8.4.png" alt="Mou icon" /></p>

<h4>8.3.1、隐式过渡</h4>

<p>CATransision可以对图层任何变化平滑过渡，这使得它为不好做动画的属性图层能够很好地提供动画支持。</p>

<p>当设置了CALayer的content属性的时候，CATransition的确是默认的行为。</p>

<p>但是对于视图关联的图层，或者是其他隐式动画的行为，这个特性依然是被禁用的，但是对于你自己创建的图层，这意味着对图层contents图片做的改动都会自动附上淡入淡出的动画。</p>

<h4>8.3.2、驱动图层树改变</h4>

<p>CATransition并不作用于指定的图层属性，例如，在不知道UITableView哪一行被添加或者删除的情况下，直接就可以平滑地刷新它，或者在不知道UIViewController内部的视图层级的情况下对两个不同的实例做过渡动画。</p>

<p>但是要确保CATransition添加到的图层在过渡动画发生时不会在树状结构中被移除，否则CATransition将会和图层一起被移除。一般来说，你只需要将动画添加到被影响图层的superlayer。</p>

<p>小例子：为UITabBarController切换时做动画</p>

<pre><code>#import "AppDelegate.h"
#import "FirstViewController.h" 
#import "SecondViewController.h"
#import &lt;QuartzCore/QuartzCore.h&gt;

@implementation AppDelegate

- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions
{
    self.window = [[UIWindow alloc] initWithFrame: [[UIScreen mainScreen] bounds]];
    UIViewController *viewController1 = [[FirstViewController alloc] init];
    UIViewController *viewController2 = [[SecondViewController alloc] init];
    self.tabBarController = [[UITabBarController alloc] init];
    self.tabBarController.viewControllers = @[viewController1, viewController2];
    self.tabBarController.delegate = self;
    self.window.rootViewController = self.tabBarController;
    [self.window makeKeyAndVisible];
    return YES;
}

- (void)tabBarController:(UITabBarController *)tabBarController didSelectViewController:(UIViewController *)viewController
{
    ￼// 设置淡入淡出变换
    CATransition *transition = [CATransition animation];
    transition.type = kCATransitionFade;
    // 应用到tabBarController的视图上
    [self.tabBarController.view.layer addAnimation:transition forKey:nil];
}
@end
</code></pre>

<h4>8.3.3、自定义过渡</h4>

<p>CATransition只提供了四种默认动画类型，太少了。</p>

<p>但是苹果通过UIView +transitionFromView:toView:duration:options:completion:和+transitionWithView:duration:options:animations:方法提供了Core Animation的过渡特性。</p>

<p>但是这里的可用的过渡选项和CATransition的type属性提供的常量完全不同。UIView过渡方法中options参数可以由如下常量指定：</p>

<pre><code>UIViewAnimationOptionTransitionFlipFromLeft 
UIViewAnimationOptionTransitionFlipFromRight
UIViewAnimationOptionTransitionCurlUp 
UIViewAnimationOptionTransitionCurlDown
UIViewAnimationOptionTransitionCrossDissolve 
UIViewAnimationOptionTransitionFlipFromTop 
UIViewAnimationOptionTransitionFlipFromBottom
</code></pre>

<p>除了UIViewAnimationOptionTransitionCrossDissolve之外，剩下的值和CATransition类型完全没关系。</p>

<p>小例子 使用UIKit提供的方法来做过渡动画</p>

<pre><code>@interface ViewController ()
@property (nonatomic, weak) IBOutlet UIImageView *imageView;
@property (nonatomic, copy) NSArray *images;
@end
@implementation ViewController
- (void)viewDidLoad
{
    [super viewDidLoad]; // 设置图片
    self.images = @[[UIImage imageNamed:@"Anchor.png"],
                    [UIImage imageNamed:@"Cone.png"],
                    [UIImage imageNamed:@"Igloo.png"],
                    [UIImage imageNamed:@"Spaceship.png"]];
- (IBAction)switchImage
{
    [UIView transitionWithView:self.imageView duration:1.0
                       options:UIViewAnimationOptionTransitionFlipFromLeft
                    animations:^{
                        // 切换到下一张图片
                         UIImage *currentImage = self.imageView.image;
                         NSUInteger index = [self.images indexOfObject:currentImage];
                         index = (index + 1) % [self.images count];
                         self.imageView.image = self.images[index];
                    }
                    completion:NULL];
}

@end
</code></pre>

<p>过渡动画的原则就是对原始的图层外观截图，然后添加一段动画，平滑过渡到图层改变之后那个截图的效果。</p>

<p>如果我们知道如何对图层截图，我们就可以使用属性动画来代替CATransition或者是UIKit的过渡方法来实现动画。</p>

<p>CALayer有一个-renderInContext:方法，可以通过把它绘制到Core Graphics的上下文中捕获当前内容的图片，然后在另外的视图中显示出来。如果我们把这个截屏视图置于原始视图之上，就可以遮住真实视图的所有变化，于是重新创建了一个简单的过渡效果。</p>

<p>小例子：用renderInContext:创建自定义过渡效果</p>

<pre><code>@implementation ViewController
- (IBAction)performTransition
{
    // 截图
    UIGraphicsBeginImageContextWithOptions(self.view.bounds.size, YES, 0.0);
    [self.view.layer renderInContext:UIGraphicsGetCurrentContext()];
    UIImage *coverImage = UIGraphicsGetImageFromCurrentImageContext();
    // 插入截图
    UIView *coverView = [[UIImageView alloc] initWithImage:coverImage];
    coverView.frame = self.view.bounds;
    [self.view addSubview:coverView];
    // 更新视图（设置一个随机的背景色）
    CGFloat red = arc4random() / (CGFloat)INT_MAX;
    CGFloat green = arc4random() / (CGFloat)INT_MAX;
    CGFloat blue = arc4random() / (CGFloat)INT_MAX;
    self.view.backgroundColor = [UIColor colorWithRed:red green:green blue:blue alpha:1.0];
    // 做自定义动画
    [UIView animateWithDuration:1.0 animations:^{
        // 放缩旋转和淡入淡出
        CGAffineTransform transform = CGAffineTransformMakeScale(0.01, 0.01);
        transform = CGAffineTransformRotate(transform, M_PI_2);
        coverView.transform = transform;
        coverView.alpha = 0.0;
    } completion:^(BOOL finished) {
        // 动画结束移除覆盖层
        [coverView removeFromSuperview];
    }];
}
@end
</code></pre>

<p><img src="http://github-octopress.qiniudn.com/CoreAnimationAdvanced8.5.png" alt="Mou icon" /></p>

<h3>8.4、取消进行中的动画</h3>

<p>之前说过，可以用-addAnimation:forKey:方法中的key参数来在添加动画之后检索一个动画</p>

<pre><code>- (CAAnimation *)animationForKey:(NSString *)key;
</code></pre>

<p>但并不支持在动画运行过程中修改动画，所以这个方法主要用来检测动画的属性，或者判断它是否被添加到当前图层中。</p>

<p>为了终止一个指定的动画，你可以用如下方法把它从图层移除掉：</p>

<pre><code>- (void)removeAnimationForKey:(NSString *)key;
</code></pre>

<p>或者移除所有动画：</p>

<pre><code>- (void)removeAllAnimations;
</code></pre>

<p>动画一旦被移除，图层的外观就<code>立刻</code>更新到当前的模型图层的值。</p>

<p>一般说来，动画在结束之后被自动移除，除非设置removedOnCompletion为NO，如果你设置动画在结束之后不被自动移除，那么当它不需要的时候你要手动移除它；否则它会一直存在于内存中，直到图层被销毁。</p>

<p>小例子：开始和停止一个动画，用之前旋转飞船的代码，增加一个按钮来停止或启动动画，-animationDidStop:finished:方法的flag参数表面动画是否停止</p>

<pre><code>@interface ViewController ()

@property (nonatomic, weak) IBOutlet UIView *containerView;
@property (nonatomic, strong) CALayer *shipLayer;

@end

@implementation ViewController

- (void)viewDidLoad
{
    [super viewDidLoad];
    // 添加飞船
    self.shipLayer = [CALayer layer];
    self.shipLayer.frame = CGRectMake(0, 0, 128, 128);
    self.shipLayer.position = CGPointMake(150, 150);
    self.shipLayer.contents = (__bridge id)[UIImage imageNamed: @"Ship.png"].CGImage;
    [self.containerView.layer addSublayer:self.shipLayer];
}

- (IBAction)start
{
    // 做旋转动画
    CABasicAnimation *animation = [CABasicAnimation animation];
    animation.keyPath = @"transform.rotation";
    animation.duration = 2.0;
    animation.byValue = @(M_PI * 2);
    animation.delegate = self;
    [self.shipLayer addAnimation:animation forKey:@"rotateAnimation"];
}

- (IBAction)stop
{
    [self.shipLayer removeAnimationForKey:@"rotateAnimation"];
}

- (void)animationDidStop:(CAAnimation *)anim finished:(BOOL)flag
{
    // 打印动画是否停止
    NSLog(@"The animation stopped (finished: %@)", flag? @"YES": @"NO");
}

@end
</code></pre>

<p><img src="http://github-octopress.qiniudn.com/CoreAnimationAdvanced8.6.png" alt="Mou icon" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Core Animation Advanced Technique 学习笔记(6)]]></title>
    <link href="http://joylong.github.io/blog/2014/08/31/core-animation-advanced-technique-6/"/>
    <updated>2014-08-31T16:19:52+08:00</updated>
    <id>http://joylong.github.io/blog/2014/08/31/core-animation-advanced-technique-6</id>
    <content type="html"><![CDATA[<h1>第二部分：运动中的设置</h1>

<h2>7、隐式动画（Implicit Animations）</h2>

<h3>7.1、事务</h3>

<p>Core Animation是基于一个说屏幕上的任何东西都可能做动画的假设为前提的。Core Animation中动画的默认开启，要关闭需要手动设置。</p>

<p>当改变CALayer那个是否可以做动画的属性时，并不能立刻在屏幕上体现出来。相反，它是从先前的值平滑过渡到新的值。这一切都是默认的行为，你不需要做额外的操作。</p>

<p>小例子：创建一个蓝色方块，然后添加一个按钮，随机改变图层颜色</p>

<pre><code>@interface ViewController ()

@property (nonatomic, weak) IBOutlet UIView *layerView;
@property (nonatomic, weak) IBOutlet CALayer *colorLayer;

@end

@implementation ViewController

- (void)viewDidLoad
{
    [super viewDidLoad];
    // 创建子图层
    self.colorLayer = [CALayer layer];
    self.colorLayer.frame = CGRectMake(50.0f, 50.0f, 100.0f, 100.0f);
    self.colorLayer.backgroundColor = [UIColor blueColor].CGColor;
    // 添加到视图尚
    [self.layerView.layer addSublayer:self.colorLayer];
}

- (IBAction)changeColor
{
    // 随机给背景配色
    CGFloat red = arc4random() / (CGFloat)INT_MAX;
    CGFloat green = arc4random() / (CGFloat)INT_MAX;
    CGFloat blue = arc4random() / (CGFloat)INT_MAX;
    self.colorLayer.backgroundColor = [UIColor colorWithRed:red green:green blue:blue alpha:1.0].CGColor;                                                                                       ￼
}

@end
</code></pre>

<p><img src="http://github-octopress.qiniudn.com/CoreAnimationAdvanced7.1.jpg" alt="Mou icon" /></p>

<p>这其实就是所谓的隐式动画。之所以叫内联是因为我们并没有指定任何动画的类型。改变了一个属性，然后Core Animation来决定如何并且何时去做动画。Core Animaiton同样支持显式动画，之后会说明。</p>

<p>当你改变一个属性，Core Animation是如何判断动画类型和持续时间的呢？实际上动画执行的时间取决于当前事务的设置，动画类型取决于图层行为。</p>

<p>事务指的是Core Animation用来包含一系列属性动画集合的机制，任何用指定事务去改变做动画的图层，属性都不会立刻发生变化，而是当事务一旦提交的时候开始用一个动画过渡到新值。</p>

<p>事务是通过CATransaction类来做管理，这个类不是去管理一个简单的事务，而是管理了很多不能访问的事务。</p>

<p>CATransaction没有属性或者实例方法，并且也不能用+alloc和-init方法创建它。但是可以用+begin和+commit分别来入栈或者出栈。</p>

<p>任何可以做动画的图层属性都会被添加到栈顶的事务，你可以通过+setAnimationDuration:方法设置当前事务的动画时间，或者通过+animationDuration方法来获取值（默认0.25秒）。</p>

<p>Core Animation在每个run loop周期中自动开始一次新的事务（run loop是iOS负责收集用户输入，处理定时器或者网络事件并且重新绘制屏幕的东西），即使你不显式的用[CATransaction begin]开始一次事务，任何在一次run loop循环中属性的改变都会被集中起来，然后做一次0.25秒的动画。</p>

<p>明白这些之后，我们就可以轻松修改改变颜色的动画的时间了。我们当然可以用当前事务的+setAnimationDuration:方法来修改动画时间，但在这里我们首先开始一个新的事务，于是修改时间就不会有别的副作用。</p>

<p>因为修改当前事务的时间可能会导致同一时刻别的动画（如屏幕旋转），所以最好还是在调整动画之前压入一个新的事务。</p>

<p>修改后的例子：使用CATransaction控制动画时间</p>

<pre><code>- (IBAction)changeColor
{
    // 开始一个新的事务
    [CATransaction begin];
    // 设置1秒的动画
    [CATransaction setAnimationDuration:1.0];
    // 随机给背景配色
    CGFloat red = arc4random() / (CGFloat)INT_MAX;
    CGFloat green = arc4random() / (CGFloat)INT_MAX;
    CGFloat blue = arc4random() / (CGFloat)INT_MAX;
    self.colorLayer.backgroundColor = [UIColor colorWithRed:red green:green blue:blue alpha:1.0].CGColor;
￼ // 提交事务
    [CATransaction commit];
}
</code></pre>

<p>如果你用过UIView的动画方法，那么应该对这个模式不陌生。</p>

<p>UIView有两个方法，+beginAnimations:context:和+commitAnimations，和CATransaction的+begin和+commit方法类似。实际上在+beginAnimations:context:和+commitAnimations之间所有视图或者图层属性的改变而做的动画都是由于设置了CATransaction的原因。</p>

<p>在iOS4中，苹果对UIView添加了一种基于block的动画方法：+animateWithDuration:animations:。这样写对做一堆的属性动画在语法上会更加简单，但实质上它们都是在做同样的事情。</p>

<p>CATransaction的+begin和+commit方法在+animateWithDuration:animations:内部自动调用，这样block中所有属性的改变都会被事务所包含。这样也可以避免开发者由于对+begin和+commit匹配的失误造成的风险。</p>

<h3>7.2、完成块</h3>

<p>基于UIView的block的动画允许你在动画结束的时候提供一个完成的动作。</p>

<p>CATranscation接口提供的+setCompletionBlock:方法也有同样的功能。</p>

<p>小例子 在颜色动画完成之后添加一个回调</p>

<pre><code>- (IBAction)changeColor
{
    // 开始新的事务
    [CATransaction begin];
    // 设置动画时间1秒
    [CATransaction setAnimationDuration:1.0];
    // 添加动画完成的操作
    [CATransaction setCompletionBlock:^{
        // 旋转图层90度
        CGAffineTransform transform = self.colorLayer.affineTransform;
        transform = CGAffineTransformRotate(transform, M_PI_2);
        self.colorLayer.affineTransform = transform;
    }];
    // 随机给背景配色
    CGFloat red = arc4random() / (CGFloat)INT_MAX;
    CGFloat green = arc4random() / (CGFloat)INT_MAX;
    CGFloat blue = arc4random() / (CGFloat)INT_MAX;
    self.colorLayer.backgroundColor = [UIColor colorWithRed:red green:green blue:blue alpha:1.0].CGColor;
    // 提交事务
    [CATransaction commit];
}
</code></pre>

<p><img src="http://github-octopress.qiniudn.com/CoreAnimationAdvanced7.2.jpg" alt="Mou icon" /></p>

<p>注意旋转动画要比颜色渐变快得多，这是因为完成块是在颜色渐变的事务提交并出栈之后才被执行，于是，用默认的事务做变换，默认的时间也就变成了0.25秒。</p>

<h3>7.3、图层动作</h3>

<p>现在来做个实验，试着直接对UIView关联的图层做动画而不是一个单独的图层。</p>

<p>小例子：直接设置图层的属性</p>

<pre><code>@interface ViewController ()

@property (nonatomic, weak) IBOutlet UIView *layerView;

@end

@implementation ViewController

- (void)viewDidLoad
{
    [super viewDidLoad];
    // 设置layerView寄宿图层的背景色
    self.layerView.layer.backgroundColor = [UIColor blueColor].CGColor;
}

- (IBAction)changeColor
{
    // 开始一个新事务
    [CATransaction begin];
    // 设置一秒动画
    [CATransaction setAnimationDuration:1.0];
    // 随机给图层背景配色
    CGFloat red = arc4random() / (CGFloat)INT_MAX;
    CGFloat green = arc4random() / (CGFloat)INT_MAX;
    CGFloat blue = arc4random() / (CGFloat)INT_MAX;
    self.layerView.layer.backgroundColor = [UIColor colorWithRed:red green:green blue:blue alpha:1.0].CGColor;
    // 提交事务
    [CATransaction commit];
}
</code></pre>

<p>运行程序，你会发现当按下按钮，图层颜色瞬间切换到新的值，而不是之前平滑过渡的动画。</p>

<p>发生了什么呢？隐式动画好像被UIView关联图层给禁用了。</p>

<p>首先，需要知道隐式动画的实现方式。</p>

<p>改变属性时CALayer自动应用的动画就是行为，当CALayer的属性被修改时候，它会调用-actionForKey:方法，传递属性的名称。剩下的操作都在CALayer的头文件中有详细的说明，实质上是如下几步：</p>

<ul>
<li><p>图层首先检测它是否有委托，并且是否实现CALayerDelegate协议指定的-actionForLayer:forKey方法。如果有，直接调用并返回结果。</p></li>
<li><p>如果没有委托，或者委托没有实现-actionForLayer:forKey方法，图层接着检查包含属性名称对应行为映射的actions字典。</p></li>
<li><p>如果actions字典没有包含对应的属性，那么图层接着在它的style字典接着搜索属性名。</p></li>
<li><p>最后，如果在style里面也找不到对应的行为，那么图层将会直接调用定义了每个属性的标准行为的-defaultActionForKey:方法。</p></li>
<li><p>所以一轮完整的搜索结束之后，-actionForKey:要么返回空（这种情况下将不会有动画发生），要么是CAAction协议对应的对象，最后CALayer拿这个结果去对先前和当前的值做动画。</p></li>
</ul>


<p>于是这就解释了UIKit是如何禁用隐式动画的：</p>

<pre><code>每个UIView对它关联的图层都扮演了一个委托，并且提供了-actionForLayer:forKey的实现方法。当不在一个动画块的实现中，UIView对所有图层行为返回nil，但是在动画block范围之内，它就返回了一个非空值。
</code></pre>

<p>小例子：测试UIView的actionForLayer:forKey:实现</p>

<pre><code>@interface ViewController ()

@property (nonatomic, weak) IBOutlet UIView *layerView;

@end

@implementation ViewController

- (void)viewDidLoad
{
    [super viewDidLoad];
    // 测试图层动作
    NSLog(@"Outside: %@", [self.layerView actionForLayer:self.layerView.layer forKey:@"backgroundColor"]);
    // 开始动画块
    [UIView beginAnimations:nil context:nil];
    // 测试图层动作
    NSLog(@"Inside: %@", [self.layerView actionForLayer:self.layerView.layer forKey:@"backgroundColor"]);
    // 结束动画块
    [UIView commitAnimations];
}

@end
</code></pre>

<p>运行程序，控制台显示结果如下：</p>

<pre><code>$ LayerTest[21215:c07] Outside: &lt;null&gt;
$ LayerTest[21215:c07] Inside: &lt;CABasicAnimation: 0x757f090&gt;
</code></pre>

<p>于是可以预言，当属性在动画块之外发生改变，UIView直接通过返回nil来禁用隐式动画。</p>

<p>但如果在动画块范围之内，根据动画具体类型返回相应的属性。</p>

<p>当然返回nil并不是禁用隐式动画唯一的办法，CATransacition有个方法叫做+setDisableActions:，可以用来对所有属性打开或者关闭隐式动画。</p>

<p>如果在之前的[CATransaction begin]之后添加下面的代码，同样也会阻止动画的发生：</p>

<pre><code>[CATransaction setDisableActions:YES];
</code></pre>

<p>总结一下，我们知道了如下几点</p>

<ul>
<li><p>UIView关联的图层禁用了隐式动画，对这种图层做动画的唯一办法就是使用UIView的动画函数（而不是依赖CATransaction），或者继承UIView，并覆盖-actionForLayer:forKey:方法，或者直接创建一个显式动画。</p></li>
<li><p>对于单独存在的图层，我们可以通过实现图层的-actionForLayer:forKey:委托方法，或者提供一个actions字典来控制隐式动画。</p></li>
</ul>


<p>我们来对颜色渐变的例子使用一个不同的行为，要么可以通过给colorLayer设置一个自定义的actions字典，或者也可以使用委托来实现，但是actions字典可以写更少的代码。</p>

<p>到底如何创建一个合适的行为对象呢？</p>

<p>行为通常是一个被Core Animation隐式调用的显式动画对象。</p>

<p>这里我们使用的是一个实现了CATransaction的实例，叫做推进过渡。CATransition能响应CAAction协议，并且可以当做一个图层行为</p>

<p>小例子：实现自定义行为</p>

<pre><code>@interface ViewController ()

@property (nonatomic, weak) IBOutlet UIView *layerView;
@property (nonatomic, weak) IBOutlet CALayer *colorLayer;

@end    

@implementation ViewController

- (void)viewDidLoad
{
    [super viewDidLoad];

    // 创建子图层
    self.colorLayer = [CALayer layer];
    self.colorLayer.frame = CGRectMake(50.0f, 50.0f, 100.0f, 100.0f);
    self.colorLayer.backgroundColor = [UIColor blueColor].CGColor;
    // 增加自定义行为
    CATransition *transition = [CATransition animation];
    transition.type = kCATransitionPush;
    transition.subtype = kCATransitionFromLeft;
    self.colorLayer.actions = @{@"backgroundColor": transition};
    // 添加到视图尚
    [self.layerView.layer addSublayer:self.colorLayer];
}

- (IBAction)changeColor
{
    // 随机给图层背景配色
    CGFloat red = arc4random() / (CGFloat)INT_MAX;
    CGFloat green = arc4random() / (CGFloat)INT_MAX;
    CGFloat blue = arc4random() / (CGFloat)INT_MAX;
    self.colorLayer.backgroundColor = [UIColor colorWithRed:red green:green blue:blue alpha:1.0].CGColor;
}

@end
</code></pre>

<p><img src="http://github-octopress.qiniudn.com/CoreAnimationAdvanced7.3.jpg" alt="Mou icon" /></p>

<h3>7.4、表现与模型</h3>

<p>CALayer的属性行为,在改变一个图层的属性后并没有立刻生效，而是通过一段时间渐变更新。这是怎么做到的呢？</p>

<p>当你改变一个图层的属性，属性值的确是立刻更新的（如果你读取它的数据，你会发现它的值在你设置它的那一刻就已经生效了），但是屏幕上并没有马上发生改变。</p>

<p>这是因为你设置的属性并没有直接调整图层的外观，相反，他只是定义了图层动画结束之后将要变化的外观。</p>

<p>当设置CALayer的属性，实际上是在定义当前事务结束之后图层如何显示的模型。</p>

<p>Core Animation扮演了一个控制器的角色，并且负责根据图层行为和事务设置去不断更新视图的这些属性在屏幕上的状态。</p>

<p>CALayer是一个连接用户界面（就是MVC中的view）虚构的类，但是在界面本身这个场景下，CALayer的行为更像是存储了视图如何显示和动画的数据模型。</p>

<p>实际上，在苹果自己的文档中，图层树通常都是值的图层树模型。</p>

<p>在iOS中，屏幕每秒钟重绘60次。如果动画时长比60分之一秒要长，Core Animation就需要在设置一次新值和新值生效之间，对屏幕上的图层进行重新组织。这意味着CALayer除了“真实”值（就是你设置的值）之外，必须要知道当前显示在屏幕上的属性值的记录。</p>

<p>每个图层属性的显示值都被存储在一个叫做表现图层的独立图层当中，他可以通过-presentationLayer方法来访问。</p>

<p>这个图层实际上是模型图层的复制，但是它的属性值代表了在任何指定时刻当前外观效果。</p>

<p>换句话说，你可以通过表现图层的值来获取当前屏幕上真正显示出来的值（图7.4）。</p>

<p>表现树通过图层树中所有图层的表现图层所形成。注：表现图层仅仅当图层首次被提交（就是首次第一次在屏幕上显示）的时候创建，所以在那之前调用-presentationLayer将会返回nil。</p>

<p>你可能注意到有一个叫做–modelLayer的方法。在表现图层上调用–modelLayer将会返回它正在呈现所依赖的CALayer。通常在一个图层上调用-modelLayer会返回–self（实际上我们已经创建的原始图层就是一种数据模型）。</p>

<p><img src="http://github-octopress.qiniudn.com/CoreAnimationAdvanced7.4.jpg" alt="Mou icon" /></p>

<p>大多数情况下，你不需要直接访问表现图层，你可以通过和模型图层的交互，来让Core Animation更新显示。两种情况下呈现图层会变得很有用，一个是同步动画，一个是处理用户交互。</p>

<p>如果你在实现一个基于定时器的动画，而不仅仅是基于事务的动画，这个时候准确地知道在某一时刻图层显示在什么位置就会对正确摆放图层很有用了。</p>

<p>如果你想让你做动画的图层响应用户输入，你可以使用-hitTest:方法来判断指定图层是否被触摸，这时候对表现图层而不是模型图层调用-hitTest:会显得更有意义，因为表现图层代表了用户当前看到的图层位置，而不是当前动画结束之后的位置。</p>

<p>小例子：使用presentationLayer图层来判断当前图层位置（点击屏幕的任意位置会让图层平移到哪里，点击图层本身则会随机改变它的颜色，通过对表现图层调用-hitTest:来判断是否被点击，如果让-hitTest:直接作用于colorLayer而不是表现图层，则图层移动时不能正确显示，这时候就需要点击图层将要移动到的那个位置而不是图层本身来响应点击）</p>

<pre><code>@interface ViewController ()

@property (nonatomic, strong) CALayer *colorLayer;

@end

@implementation ViewController

- (void)viewDidLoad
{
    [super viewDidLoad];
    // 创建一个红色图层
    self.colorLayer = [CALayer layer];
    self.colorLayer.frame = CGRectMake(0, 0, 100, 100);
    self.colorLayer.position = CGPointMake(self.view.bounds.size.width / 2, self.view.bounds.size.height / 2);
    self.colorLayer.backgroundColor = [UIColor redColor].CGColor;
    [self.view.layer addSublayer:self.colorLayer];
}

- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event
{
    // 得到触摸点
    CGPoint point = [[touches anyObject] locationInView:self.view];
    // 检查是否点击了移动中的图层
    if ([self.colorLayer.presentationLayer hitTest:point]) {
        // 给图层背景随机配色
        CGFloat red = arc4random() / (CGFloat)INT_MAX;
        CGFloat green = arc4random() / (CGFloat)INT_MAX;
        CGFloat blue = arc4random() / (CGFloat)INT_MAX;
        self.colorLayer.backgroundColor = [UIColor colorWithRed:red green:green blue:blue alpha:1.0].CGColor;
    } else {
        // 否则移动图层到新的位置
        [CATransaction begin];
        [CATransaction setAnimationDuration:4.0];
        self.colorLayer.position = point;
        [CATransaction commit];
    }
}
@end
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Core Animation Advanced Technique 学习笔记(5)]]></title>
    <link href="http://joylong.github.io/blog/2014/08/30/core-animation-advanced-technique-5/"/>
    <updated>2014-08-30T18:52:47+08:00</updated>
    <id>http://joylong.github.io/blog/2014/08/30/core-animation-advanced-technique-5</id>
    <content type="html"><![CDATA[<h1>第一部分：下面的图层</h1>

<h2>6、专用图层(Specialized Layers)</h2>

<h3>6.1、CAShapeLayer</h3>

<p>CAShapeLayer是一个通过矢量图形而不是bitmap来绘制的图层子类。</p>

<p>你指定诸如颜色和线宽等属性，用CGPath来定义想要绘制的图形，最后CAShapeLayer就会自动渲染出来。</p>

<p>当然，也可以用Core Graphics直接向原始的CALyer的内容中绘制路径，不过，使用CAShapeLayer有以下一些优点：</p>

<ul>
<li><p>快。CAShapeLayer使用了硬件加速，绘制比Core Graphics快很多。</p></li>
<li><p>高效使用内存。CAShapeLayer不需要像普通CALayer一样创建一个寄宿图形，所以无论有多大，都不会占用太多的内存。</p></li>
<li><p>不会被图层边界剪裁掉。CAShapeLayer可以在边界之外绘制。图层路径不会像在使用Core Graphics的CALayer一样被剪裁掉。</p></li>
<li><p>不会出现像素化。当你给CAShapeLayer做3D变换时，它不像一个有寄宿图的普通图层一样变得像素化。</p></li>
</ul>


<h4>6.1.1、创建一个CGPath</h4>

<p>CAShapeLayer可以用来绘制所有能够通过CGPath来表示的形状。</p>

<p>形状不一定要闭合，图层路径也不一定要不可破，你可以在一个图层上绘制好几个不同的形状。可以控制一些属性比如lineWith（线宽，用点表示单位），lineCap（线条结尾的样子），和lineJoin（线条之间的结合点的样子）；</p>

<p>但是在图层层面你只有一次机会设置这些属性。</p>

<p>如果你想用不同颜色或风格来绘制多个形状，就不得不为每个形状准备一个图层了。</p>

<p>下面的代码用一个CAShapeLayer绘制一个简单的火柴人。
CAShapeLayer属性是CGPathRef类型，但是我们用UIBezierPath帮助类创建了图层路径，这样我们就不用考虑人工释放CGPath了。</p>

<pre><code>#import "DrawingView.h"
#import &lt;QuartzCore/QuartzCore.h&gt;

@interface ViewController ()

@property (nonatomic, weak) IBOutlet UIView *containerView;

@end

@implementation ViewController

- (void)viewDidLoad
{
    [super viewDidLoad];
    // 创建路径
    UIBezierPath *path = [[UIBezierPath alloc] init];
    [path moveToPoint:CGPointMake(175, 100)];
    [path addArcWithCenter:CGPointMake(150, 100) radius:25 startAngle:0 endAngle:2*M_PI clockwise:YES];
    [path moveToPoint:CGPointMake(150, 125)];
    [path addLineToPoint:CGPointMake(150, 175)];
    [path addLineToPoint:CGPointMake(125, 225)];
    [path moveToPoint:CGPointMake(150, 175)];
    [path addLineToPoint:CGPointMake(175, 225)];
    [path moveToPoint:CGPointMake(100, 150)];
    [path addLineToPoint:CGPointMake(200, 150)];

    // 创建CAShapeLayer
    CAShapeLayer *shapeLayer = [CAShapeLayer layer];
    shapeLayer.strokeColor = [UIColor redColor].CGColor;
    shapeLayer.fillColor = [UIColor clearColor].CGColor;
    shapeLayer.lineWidth = 5;
    shapeLayer.lineJoin = kCALineJoinRound;
    shapeLayer.lineCap = kCALineCapRound;
    shapeLayer.path = path.CGPath;
    // 添加到视图上
    [self.containerView.layer addSublayer:shapeLayer];
}
@end
</code></pre>

<p><img src="http://github-octopress.qiniudn.com/CoreAnimationAdvanced6.1.png" alt="Mou icon" /></p>

<h4>6.1.2、用CAShapeLayer为每个角指定是否圆角</h4>

<p>之前提到了CAShapeLayer为创建圆角视图提供了一个方法，就是CALayer的cornerRadius属性。</p>

<p>虽然使用CAShapeLayer类需要更多的工作，但是它有一个优势就是可以单独指定每个角。</p>

<p>下面这段代码绘制了一个有三个圆角一个直角的矩形：</p>

<pre><code>// 定义路径参数
CGRect rect = CGRectMake(50, 50, 100, 100);
CGSize radii = CGSizeMake(20, 20);
UIRectCorner corners = UIRectCornerTopRight | UIRectCornerBottomRight | UIRectCornerBottomLeft;
// 创建路径
UIBezierPath *path = [UIBezierPath bezierPathWithRoundedRect:rect byRoundingCorners:corners cornerRadii:radii];
</code></pre>

<p>我们可以通过这个图层路径绘制一个既有直角又有圆角的视图。</p>

<p>如果我们想依照此图形来剪裁视图内容，我们可以把CAShapeLayer作为视图的宿主图层(backing layer)，而不是添加一个子视图。</p>

<h3>6.2、CATextLayer</h3>

<p>如果你想在一个图层里面显示文字，完全可以借助图层代理直接将字符串使用Core Graphics写入图层的内容（这就是UILabel的精髓）。如果越过寄宿于图层的视图，直接在图层上操作，那其实相当繁琐。你要为每一个显示文字的图层创建一个能像图层代理一样工作的类，还要逻辑上判断哪个图层需要显示哪个字符串，更别提还要记录不同的字体，颜色等一系列乱七八糟的东西。</p>

<p>幸运的是，Core Animation提供了一个CALayer的子类CATextLayer，它以图层的形式包含了UILabel几乎所有的绘制特性，并且额外提供了一些新的特性。</p>

<p>同样，CATextLayer也要比UILabel渲染得快得多。</p>

<p>iOS 6及之前的版本，UILabel其实是通过WebKit来实现绘制的，这样就造成了当有很多文字的时候就会有极大的性能压力。</p>

<p>而CATextLayer使用了Core text，并且渲染得非常快。</p>

<h4>6.2.1、用CATextLayer来实现一个UILabel</h4>

<pre><code>@interface ViewController ()

@property (nonatomic, weak) IBOutlet UIView *labelView;

@end

@implementation ViewController
- (void)viewDidLoad
{
    [super viewDidLoad];

    // 创建一个CATextLayer
    CATextLayer *textLayer = [CATextLayer layer];
    textLayer.frame = self.labelView.bounds;
    [self.labelView.layer addSublayer:textLayer];

    // 设置文本属性
    textLayer.foregroundColor = [UIColor blackColor].CGColor;
    textLayer.alignmentMode = kCAAlignmentJustified;
    textLayer.wrapped = YES;

    // 选择字体
    UIFont *font = [UIFont systemFontOfSize:15];

    // 设置图层字体
    CFStringRef fontName = (__bridge CFStringRef)font.fontName;
    CGFontRef fontRef = CGFontCreateWithFontName(fontName);
    textLayer.font = fontRef;
    textLayer.fontSize = font.pointSize;
    CGFontRelease(fontRef);

    // 设置文本
    NSString *text = @"Lorem ipsum dolor sit amet, consectetur adipiscing \ elit. Quisque massa arcu, eleifend vel varius in, facilisis pulvinar \ leo. Nunc quis nunc at mauris pharetra condimentum ut ac neque. Nunc elementum, libero ut porttitor dictum, diam odio congue lacus, vel \ fringilla sapien diam at purus. Etiam suscipit pretium nunc sit amet \ lobortis";

    // 设置图层文本
    textLayer.string = text;
}
@end
</code></pre>

<p><img src="http://github-octopress.qiniudn.com/CoreAnimationAdvanced6.2.png" alt="Mou icon" /></p>

<p>如果你放大看这个文本，会发现这些文本有一些像素化了。</p>

<p>这是因为并没有以Retina的方式渲染，之前提到过contentScale属性，是用来决定图层内容应该以怎样的分辨率来渲染。</p>

<p>contentsScale并不关心屏幕的拉伸因素而总是默认为1.0。如果我们想以Retina的质量来显示文字，我们就得手动地设置CATextLayer的contentsScale属性，</p>

<p>如下：</p>

<pre><code>textLayer.contentsScale = [UIScreen mainScreen].scale;
</code></pre>

<p>这样就解决了这个问题，如下图</p>

<p><img src="http://github-octopress.qiniudn.com/CoreAnimationAdvanced6.3.png" alt="Mou icon" /></p>

<p>CATextLayer的font属性并不是一个UIFont，而是一个CFTypeRef类型。</p>

<p>这样可以根据你的具体需要来决定字体属性应该是用CGFontRef类型还是CTFontRef类型（Core Text字体）。</p>

<p>同时字体大小也是用fontSize属性单独设置的，因为CTFontRef和CGFontRef并不像UIFont一样包含点大小。</p>

<p>这个例子会告诉你如何将UIFont转换成CGFontRef。</p>

<p>另外，CATextLayer的string属性并不是你想象的NSString类型，而是id类型。这样你既可以用NSString也可以用NSAttributedString来设置文本了（注：NSAttributedString并不是NSString的子类）。</p>

<h4>6.2.2、富文本</h4>

<p>iOS 6中，Apple给UILabel和其他UIKit文本视图添加了对属性化字符串（NSAttributedString）的支持，应该说这是一个很方便的特性。</p>

<p>但是从iOS3.2开始CATextLayer就已经支持属性化字符串了。这样的话，如果你想要支持更低版本的iOS系统，CATextLayer无疑是你向界面中增加富文本的好办法，而且也不用去跟复杂的Core Text打交道，也省了用UIWebView的麻烦。</p>

<p>用NSAttributedString实现一个富文本标签。</p>

<pre><code>#import "DrawingView.h"
#import &lt;QuartzCore/QuartzCore.h&gt;
#import &lt;CoreText/CoreText.h&gt;

@interface ViewController ()

@property (nonatomic, weak) IBOutlet UIView *labelView;

@end

@implementation ViewController

- (void)viewDidLoad
{
    [super viewDidLoad];

    // 创建一个文本图层
    CATextLayer *textLayer = [CATextLayer layer];
    textLayer.frame = self.labelView.bounds;
    textLayer.contentsScale = [UIScreen mainScreen].scale;
    [self.labelView.layer addSublayer:textLayer];

    // 设置文本属性
    textLayer.alignmentMode = kCAAlignmentJustified;
    textLayer.wrapped = YES;

    // 设置字体
    UIFont *font = [UIFont systemFontOfSize:15];

    // 设置文本
    NSString *text = @"Lorem ipsum dolor sit amet, consectetur adipiscing \ elit. Quisque massa arcu, eleifend vel varius in, facilisis pulvinar \ leo. Nunc quis nunc at mauris pharetra condimentum ut ac neque. Nunc \ elementum, libero ut porttitor dictum, diam odio congue lacus, vel \ fringilla sapien diam at purus. Etiam suscipit pretium nunc sit amet \ lobortis"; ￼
    // 创建属性字符串
    NSMutableAttributedString *string = nil;
    string = [[NSMutableAttributedString alloc] initWithString:text];

    // 把UIFont转换成CTFont
    CFStringRef fontName = (__bridge CFStringRef)font.fontName;
    CGFloat fontSize = font.pointSize;
    CTFontRef fontRef = CTFontCreateWithName(fontName, fontSize, NULL);

    // 设置文本属性
    NSDictionary *attribs = @{
        (__bridge id)kCTForegroundColorAttributeName:(__bridge id)[UIColor blackColor].CGColor,
        (__bridge id)kCTFontAttributeName: (__bridge id)fontRef
    };

    [string setAttributes:attribs range:NSMakeRange(0, [text length])];
        attribs = @{
        (__bridge id)kCTForegroundColorAttributeName: (__bridge id)[UIColor redColor].CGColor,
        (__bridge id)kCTUnderlineStyleAttributeName: @(kCTUnderlineStyleSingle),
        (__bridge id)kCTFontAttributeName: (__bridge id)fontRef
    };
    [string setAttributes:attribs range:NSMakeRange(6, 5)];

    // 释放CTFont
    CFRelease(fontRef);

    // 设置图层文本
    textLayer.string = string;
}
@end
</code></pre>

<p><img src="http://github-octopress.qiniudn.com/CoreAnimationAdvanced6.4.png" alt="Mou icon" /></p>

<h4>6.2.3、行距和字距</h4>

<p>由于绘制的实现机制不同（Core Text和WebKit），用CATextLayer渲染和用UILabel渲染出的文本行距和字距也不是不尽相同的。二者的差异程度（由使用的字体和字符决定）总的来说挺小。</p>

<p>但是如果你想正确的显示普通便签和CATextLayer就一定要记住这一点。</p>

<p>已经可以确定的是CATextLayer比UILabel有着更好的性能表现，同时还有额外的布局选项并且在iOS 5上支持富文本。</p>

<p>但是与一般的标签比较而言会更加繁琐一些。如果我们真的在需求一个UILabel的可用替代品，应该继承UILabel，然后添加一个子图层CATextLayer并重写显示文本的方法。</p>

<p>但是仍然会有由UILabel的-drawRect:方法创建的空寄宿图。而且由于CALayer不支持自动缩放和自动布局，子视图并不是主动跟踪视图边界的大小，所以每次视图大小被更改，我们不得不手动更新子图层的边界。</p>

<p>我们真正想要的是一个用CATextLayer作为宿主图层的UILabel子类，这样就可以随着视图自动调整大小而且也没有冗余的寄宿图啦。这个图层是由视图自动创建和管理的，一旦被创建，我们就无法替代这个图层了。但是如果继承了UIView，那我们就可以重写+layerClass方法使得在创建的时候能返回一个不同的图层子类。UIView会在初始化的时候调用+layerClass方法，然后用它的返回类型来创建宿主图层。</p>

<p>下面的例子演示了使用CATextLayer的UILabel子类：LayerLabel，而不是调用一般的UILabel使用的较慢的-drawRect：方法。</p>

<pre><code>#import "LayerLabel.h"
#import &lt;QuartzCore/QuartzCore.h&gt;

@implementation LayerLabel
+ (Class)layerClass
{
    // 这个方法让Label创建一个CATextLayer而不是原本的CALayer作为寄宿图
    return [CATextLayer class];
}

- (CATextLayer *)textLayer
{
    return (CATextLayer *)self.layer;
}

- (void)setUp
{
    // 根据UILabel的设置来设置默认项
    self.text = self.text;
    self.textColor = self.textColor;
    self.font = self.font;



    [self textLayer].alignmentMode = kCAAlignmentJustified;
</code></pre>

<p>  ￼
        [self textLayer].wrapped = YES;
        [self.layer display];
    }</p>

<pre><code>- (id)initWithFrame:(CGRect)frame
{
    // 创建Label时自动调用
    if (self = [super initWithFrame:frame]) {
        [self setUp];
    }
    return self;
}

- (void)awakeFromNib
{
    // 使用IB创建时调用
    [self setUp];
}

- (void)setText:(NSString *)text
{
    super.text = text;
    // 设置图层颜色
    [self textLayer].string = text;
}

- (void)setTextColor:(UIColor *)textColor
{
    super.textColor = textColor;
    // 设置图层文本颜色
    [self textLayer].foregroundColor = textColor.CGColor;
}

- (void)setFont:(UIFont *)font
{
    super.font = font;
    // 设置图层字体
    CFStringRef fontName = (__bridge CFStringRef)font.fontName;
    CGFontRef fontRef = CGFontCreateWithFontName(fontName);
    [self textLayer].font = fontRef;
    [self textLayer].fontSize = font.pointSize;
</code></pre>

<p>  ￼ <br/>
        CGFontRelease(fontRef);
    }
    @end</p>

<p>如果你运行代码，你会发现文本并没有模糊，而我们也没有设置contentsScale属性。把CATextLayer作为宿主图层的另一好处就是视图自动设置了contentsScale属性。</p>

<p>如果你打算支持iOS 6及以上，基于CATextLayer的标签可能就有有些局限。</p>

<p>但是总得来说，如果想在app里面充分利用CALayer子类，用+layerClass来创建基于不同图层的视图是一个简单可复用的方法。</p>

<h3>6.3、CATransformLayer</h3>

<p>Core Animation图层很容易就可以让你在2D环境下做出层级体系下的变换，但是3D情况下就不太可能，因为所有的图层都把他的子类都平面化到一个场景中。</p>

<p>CATransformLayer解决了这个问题，CATransformLayer不同于普通的CALayer，因为它不能显示它自己的内容。存在的前提是：只有当存在了一个能作用于子图层的变换它才真正存在。</p>

<p>CATransformLayer并不平面化它的子图层，所以它能够用于构造一个层级的3D结构。</p>

<p>之前讲过，我们将通过旋转camera来解决图层平面化问题,而不是像立方体示例代码中用的sublayerTransform。这是一个非常不错的技巧，但是只能作用域单个对象上，如果你的场景包含两个立方体，那我们就不能用这个技巧单独旋转他们了。</p>

<p>如果用CATransformLayer，第一个问题就来了：之前我们是用多个视图来构造了我们的立方体，而不是单独的图层。我们不能在不打乱已有的视图层次的前提下在一个本身不是有寄宿图的图层中放置一个寄宿图图层。我们可以创建一个新的UIView子类寄宿在CATransformLayer（用+layerClass方法）之上。但是，为了简化案例，我们仅仅重建了一个单独的图层，而不是使用视图。这意味着我们不能像之前一样在立方体表面显示按钮和标签，不过我们现在也用不到这个特性。</p>

<p>下面代码就是用之前的逻辑放置立方体。但是并不像以前那样直接将立方面添加到容器视图的宿主图层，我们将他们放置到一个CATransformLayer中创建一个独立的立方体对象，然后将两个这样的立方体放进容器中。我们随机地给立方面染色以将他们区分开来，这样就不用靠标签或是高亮来区分他们。</p>

<pre><code>@interface ViewController ()

@property (nonatomic, weak) IBOutlet UIView *containerView;

@end

@implementation ViewController

- (CALayer *)faceWithTransform:(CATransform3D)transform
{
    // 创建立方体面的图层
    CALayer *face = [CALayer layer];
    face.frame = CGRectMake(-50, -50, 100, 100);

    // 选择随机色
    CGFloat red = (rand() / (double)INT_MAX);
    CGFloat green = (rand() / (double)INT_MAX);
    CGFloat blue = (rand() / (double)INT_MAX);
    face.backgroundColor = [UIColor colorWithRed:red green:green blue:blue alpha:1.0].CGColor;

    ￼// 设置transform并返回
    face.transform = transform;
    return face;
}

- (CALayer *)cubeWithTransform:(CATransform3D)transform
{
    // 创建立方体图层
    CATransformLayer *cube = [CATransformLayer layer];

    // 添加立方体面1
    CATransform3D ct = CATransform3DMakeTranslation(0, 0, 50);
    [cube addSublayer:[self faceWithTransform:ct]];

    // 添加立方体面2
    ct = CATransform3DMakeTranslation(50, 0, 0);
    ct = CATransform3DRotate(ct, M_PI_2, 0, 1, 0);
    [cube addSublayer:[self faceWithTransform:ct]];

    // 添加立方体面3
    ct = CATransform3DMakeTranslation(0, -50, 0);
    ct = CATransform3DRotate(ct, M_PI_2, 1, 0, 0);
    [cube addSublayer:[self faceWithTransform:ct]];

    // 添加立方体面4
    ct = CATransform3DMakeTranslation(0, 50, 0);
    ct = CATransform3DRotate(ct, -M_PI_2, 1, 0, 0);
    [cube addSublayer:[self faceWithTransform:ct]];

    // 添加立方体面5
    ct = CATransform3DMakeTranslation(-50, 0, 0);
    ct = CATransform3DRotate(ct, -M_PI_2, 0, 1, 0);
    [cube addSublayer:[self faceWithTransform:ct]];

    // 添加立方体面6
    ct = CATransform3DMakeTranslation(0, 0, -50);
    ct = CATransform3DRotate(ct, M_PI, 0, 1, 0);
    [cube addSublayer:[self faceWithTransform:ct]];

    // 让立方体图层居中
    CGSize containerSize = self.containerView.bounds.size;
    cube.position = CGPointMake(containerSize.width / 2.0, containerSize.height / 2.0);

    // 设置transform并返回
    cube.transform = transform;
    return cube;
}

- (void)viewDidLoad
{￼
    [super viewDidLoad];

    // 设定透视变换
    CATransform3D pt = CATransform3DIdentity;
    pt.m34 = -1.0 / 500.0;
    self.containerView.layer.sublayerTransform = pt;

    // 设定立方体1的透视并添加在图层上
    CATransform3D c1t = CATransform3DIdentity;
    c1t = CATransform3DTranslate(c1t, -100, 0, 0);
    CALayer *cube1 = [self cubeWithTransform:c1t];
    [self.containerView.layer addSublayer:cube1];

    // 设定立方体2的透视并添加在图层上
    CATransform3D c2t = CATransform3DIdentity;
    c2t = CATransform3DTranslate(c2t, 100, 0, 0);
    c2t = CATransform3DRotate(c2t, -M_PI_4, 1, 0, 0);
    c2t = CATransform3DRotate(c2t, -M_PI_4, 0, 1, 0);
    CALayer *cube2 = [self cubeWithTransform:c2t];
    [self.containerView.layer addSublayer:cube2];
}
@end
</code></pre>

<p><img src="http://github-octopress.qiniudn.com/CoreAnimationAdvanced6.5.png" alt="Mou icon" /></p>

<h3>6.4、CAGradientLayer</h3>

<p>CAGradientLayer是用来生成两种或更多颜色平滑渐变的。</p>

<p>用Core Graphics复制一个CAGradientLayer并将内容绘制到一个普通图层的寄宿图也可以实现这个效果，但是CAGradientLayer的真正好处在于绘制使用了硬件加速。</p>

<h4>6.4.1、基础渐变</h4>

<p>我们将从一个简单的红变蓝的对角线渐变开始.这些渐变色彩放在一个数组中，并赋给colors属性。</p>

<p>但是这个数组成员接受CGColorRef类型的值（并不是从NSObject派生而来），因此需要通过bridge转换以确保编译正常。</p>

<p>CAGradientLayer也有startPoint和endPoint属性，他们决定了渐变的方向。这两个参数是以单位坐标系进行的定义，所以左上角坐标是{0, 0}，右下角坐标是{1, 1}。</p>

<p>小例子：简单的两种颜色的对角线渐变</p>

<pre><code>@interface ViewController ()

@property (nonatomic, weak) IBOutlet UIView *containerView;

@end

@implementation ViewController

- (void)viewDidLoad
{
    [super viewDidLoad];
    // 创建梯度图层并添加这个图层到容器视图上
    CAGradientLayer *gradientLayer = [CAGradientLayer layer];
    gradientLayer.frame = self.containerView.bounds;
    [self.containerView.layer addSublayer:gradientLayer];

    // 设置梯度颜色
    gradientLayer.colors = @[(__bridge id)[UIColor redColor].CGColor, (__bridge id)[UIColor blueColor].CGColor];

    // 设置梯度开始和结束点
    gradientLayer.startPoint = CGPointMake(0, 0);
    gradientLayer.endPoint = CGPointMake(1, 1);
}
@end
</code></pre>

<p><img src="http://github-octopress.qiniudn.com/CoreAnimationAdvanced6.6.png" alt="Mou icon" /></p>

<h4>6.4.2、多重渐变</h4>

<p>只要你想，colors属性可以包含很多颜色，创建一个彩虹一样的多重渐变也是很简单的。</p>

<p>默认情况下，这些颜色在空间上均匀地被渲染，但是我们可以用locations属性来调整空间。</p>

<p>locations属性是一个浮点数值的数组（以NSNumber类型封装）。这些浮点数定义了colors属性中每个不同颜色的位置，同样的，也是以单位坐标系进行标定。0.0代表着渐变的开始，1.0代表着结束。</p>

<p>locations数组并不是强制要求的，但是如果你给它赋值了就一定要确保locations的数组大小和colors数组大小一定要相同，否则你将会得到一个空白的渐变。</p>

<p>下面展示了一个基于之前对角线渐变的代码改造。现在变成了从红到黄最后到绿色的渐变。locations数组指定了0.0，0.25和0.5三个数值，这样这三个渐变就有点像挤在了左上角。</p>

<pre><code>- (void)viewDidLoad {
    [super viewDidLoad];

    // 创建梯度图层并添加到容器视图上
    CAGradientLayer *gradientLayer = [CAGradientLayer layer];
    gradientLayer.frame = self.containerView.bounds;
    [self.containerView.layer addSublayer:gradientLayer];

    // 设置梯度颜色
    gradientLayer.colors = @[(__bridge id)[UIColor redColor].CGColor, (__bridge id [UIColor yellowColor].CGColor, (__bridge id)[UIColor greenColor].CGColor];

    // 设置位置
    gradientLayer.locations = @[@0.0, @0.25, @0.5];

    // 设置梯度开始和结束点
    gradientLayer.startPoint = CGPointMake(0, 0);
    gradientLayer.endPoint = CGPointMake(1, 1);
}
</code></pre>

<p><img src="http://github-octopress.qiniudn.com/CoreAnimationAdvanced6.7.png" alt="Mou icon" /></p>

<h3>6.5、CAReplicatorLayer</h3>

<p>CAReplicatorLayer可以高效生成许多相似的图层。</p>

<p>它会绘制一个或多个图层的子图层，并在每个复制体上应用不同的变换。</p>

<h4>6.5.1、重复图层（Repeating Layers）</h4>

<p>下面的例子，在屏幕的中间创建了一个小白色方块图层，然后用CAReplicatorLayer生成十个图层组成一个圆圈。</p>

<p>instanceCount属性指定了图层需要重复多少次。</p>

<p>instanceTransform指定了一个CATransform3D的变换（这种情况下，下一图层的位移和旋转将会移动到圆圈的下一个点）。</p>

<p>变换是逐步增加的，每个实例都是相对于前一实例布局。这就是为什么这些复制体最终不会出现在同意位置上。</p>

<pre><code>@interface ViewController ()

@property (nonatomic, weak) IBOutlet UIView *containerView;

@end

@implementation ViewController
- (void)viewDidLoad
{
    [super viewDidLoad];
    // 创建一个重复图层并添加到视图上
    CAReplicatorLayer *replicator = [CAReplicatorLayer layer];
    replicator.frame = self.containerView.bounds;
    [self.containerView.layer addSublayer:replicator];

    // 设置重复次数
    replicator.instanceCount = 10;

    // 为每个实例应用变换
    CATransform3D transform = CATransform3DIdentity;
    transform = CATransform3DTranslate(transform, 0, 200, 0);
    transform = CATransform3DRotate(transform, M_PI / 5.0, 0, 0, 1);
    transform = CATransform3DTranslate(transform, 0, -200, 0);
    replicator.instanceTransform = transform;

    // 为每个实例设置颜色偏移
    replicator.instanceBlueOffset = -0.1;
    replicator.instanceGreenOffset = -0.1;

    // 创建一个子图层并放置在重复图层中
    CALayer *layer = [CALayer layer];
    layer.frame = CGRectMake(100.0f, 100.0f, 100.0f, 100.0f);
    layer.backgroundColor = [UIColor whiteColor].CGColor;
    [replicator addSublayer:layer];
}
@end
</code></pre>

<p><img src="http://github-octopress.qiniudn.com/CoreAnimationAdvanced6.8.png" alt="Mou icon" /></p>

<pre><code>当图层在重复的时候，他们的颜色也在变化：这是用instanceBlueOffset和instanceGreenOffset属性实现的。

通过逐步减少蓝色和绿色通道，我们逐渐将图层颜色转换成了红色。这个复制效果看起来很酷，但是CAReplicatorLayer真正应用到实际程序上的场景比如：一个游戏中导弹的轨迹云，或者粒子爆炸（尽管iOS 5已经引入了CAEmitterLayer，它更适合创建任意的粒子效果）。
</code></pre>

<p>除此之外，还有一个实际应用是：反射。</p>

<h4>6.5.2、镜像（反射）</h4>

<p>使用CAReplicatorLayer并在一个复制图层上应用一个负比例变换，你就可以创建指定视图（或整个视图层次）内容的镜像图片，这样就创建了一个实时的镜像效果。</p>

<p>小例子：用CAReplicatorLayer自动绘制反射</p>

<pre><code>#import "ReflectionView.h"
#import &lt;QuartzCore/QuartzCore.h&gt;

@implementation ReflectionView

+ (Class)layerClass
{
    return [CAReplicatorLayer class];
}

- (void)setUp
{
    // 配置重复图层
    CAReplicatorLayer *layer = (CAReplicatorLayer *)self.layer;
    layer.instanceCount = 2;

    // 设置反射实例
    CATransform3D transform = CATransform3DIdentity;
    CGFloat verticalOffset = self.bounds.size.height + 2;
    transform = CATransform3DTranslate(transform, 0, verticalOffset, 0);
    transform = CATransform3DScale(transform, 1, -1, 0);
    layer.instanceTransform = transform;

    // 减少图层alpha
    layer.instanceAlphaOffset = -0.6;
}
</code></pre>

<p>￼
    - (id)initWithFrame:(CGRect)frame
    {
        // 用代码创建时会调用
        if ((self = [super initWithFrame:frame])) {
            [self setUp];
        }
        return self;
    }</p>

<pre><code>- (void)awakeFromNib
{
    // 用IB创建时会调用
    [self setUp];
}
@end
</code></pre>

<p><img src="http://github-octopress.qiniudn.com/CoreAnimationAdvanced6.9.png" alt="Mou icon" /></p>

<p>开源代码<a href="https://github.com/nicklockwood/ReflectionView">ReflectionView</a>完成了一个自适应的渐变淡出效果（用CAGradientLayer和图层蒙板实现）</p>

<h3>6.6、CAScrollLayer</h3>

<p>对于一个未转换的图层，它的bounds和它的frame是一样的，frame属性是由bounds属性自动计算而出的，所以更改任意一个值都会更新其他值。</p>

<p>但是如果你只想显示一个大图层里面的一小部分呢。比如说，你可能有一个很大的图片，你希望用户能够随意滑动，或者是一个数据或文本的长列表。在一个典型的iOS应用中，你可能会用到UITableView或是UIScrollView，但是对于独立的图层来说，什么会等价于刚刚提到的UITableView和UIScrollView呢？</p>

<p>之前介绍了图层的contentsRect属性的用法，它的确是能够解决在图层中小地方显示大图片的解决方法。但是如果你的图层包含子图层那它就不是一个非常好的解决方案，因为，这样做的话每次你想『滑动』可视区域的时候，你就需要手工重新计算并更新所有的子图层位置。</p>

<p>这个时候就需要CAScrollLayer了。</p>

<p>CAScrollLayer有一个-scrollToPoint:方法，它自动适应bounds的原点以便图层内容出现在滑动的地方。注意，这就是它做的所有事情。</p>

<p>前面提到过Core Animation并不处理用户输入，所以CAScrollLayer并不负责将触摸事件转换为滑动事件，既不渲染滚动条，也不实现任何iOS指定行为例如滑动反弹（当视图滑动超多了它的边界的将会反弹回正确的地方）。</p>

<p>下面的例子介绍了用CAScrollLayer来代替基础的UIScrollView。我们将会用CAScrollLayer作为视图的宿主图层，并创建一个自定义的UIView，然后用UIPanGestureRecognizer实现触摸事件响应。</p>

<pre><code>#import "ScrollView.h"
#import &lt;QuartzCore/QuartzCore.h&gt; 
@implementation ScrollView
+ (Class)layerClass
{
    return [CAScrollLayer class];
}

- (void)setUp
{
    // 可切边
    self.layer.masksToBounds = YES;

    // 绑定手势
    UIPanGestureRecognizer *recognizer = nil;
    recognizer = [[UIPanGestureRecognizer alloc] initWithTarget:self action:@selector(pan:)];
    [self addGestureRecognizer:recognizer];
}

- (id)initWithFrame:(CGRect)frame
{
    if ((self = [super initWithFrame:frame])) {
        [self setUp];
    }
    return self;
}

- (void)awakeFromNib {
    [self setUp];
}

- (void)pan:(UIPanGestureRecognizer *)recognizer
{
    // 计算偏移
    CGPoint offset = self.bounds.origin;
    offset.x -= [recognizer translationInView:self].x;
    offset.y -= [recognizer translationInView:self].y;

    // 滚动
    [(CAScrollLayer *)self.layer scrollToPoint:offset];

    // 重置
    [recognizer setTranslation:CGPointZero inView:self];
}
@end
</code></pre>

<p><img src="http://github-octopress.qiniudn.com/CoreAnimationAdvanced6.10.png" alt="Mou icon" /></p>

<p>不同于UIScrollView，我们定制的滑动视图类并没有实现任何形式的边界检查（bounds checking）。图层内容极有可能滑出视图的边界并无限滑下去。</p>

<p>CAScrollLayer并没有等同于UIScrollView中contentSize的属性，所以当CAScrollLayer滑动的时候完全没有一个全局的可滑动区域的概念，也无法自适应它的边界原点至你指定的值。</p>

<p>它之所以不能自适应边界大小是因为它不需要，内容完全可以超过边界。</p>

<p>那你一定会奇怪用CAScrollLayer的意义到底何在，因为你可以简单地用一个普通的CALayer然后手动适应边界原点啊。真相其实并不复杂，UIScrollView并没有用CAScrollLayer，事实上，就是简单的通过直接操作图层边界来实现滑动。</p>

<p>CAScrollLayer有一个潜在的有用特性。如果你查看CAScrollLayer的头文件，你就会注意到有一个扩展分类实现了一些方法和属性：</p>

<pre><code>// 从图层树中查找并找到第一个可用的CAScrollLayer，然后滑动它使得指定点成为可视的。
- (void)scrollPoint:(CGPoint)p; 
// 实现了同样的事情只不过是作用在一个矩形上的
- (void)scrollRectToVisible:(CGRect)r;
// 决定图层（如果存在的话）的哪部分是当前的可视区域。
@property(readonly) CGRect visibleRect;
</code></pre>

<p>如果你自己实现这些方法就会相对容易明白一点，但是CAScrollLayer帮你省了这些麻烦，所以当涉及到实现图层滑动的时候就可以用上了。</p>

<h3>6.7、CATiledLayer</h3>

<p>有些时候你可能需要绘制一个很大的图片，常见的例子就是一个高像素的照片或者是地球表面的详细地图。</p>

<p>iOS应用通畅运行在内存受限的设备上，所以读取整个图片到内存中是不明智的。载入大图可能会相当地慢，那些对你看上去比较方便的做法（在主线程调用UIImage的-imageNamed:方法或者-imageWithContentsOfFile:方法）将会阻塞你的用户界面，至少会引起动画卡顿现象。</p>

<p>能高效绘制在iOS上的图片也有一个大小限制。所有显示在屏幕上的图片最终都会被转化为OpenGL纹理，同时OpenGL有一个最大的纹理尺寸（通常是2048 * 2048，或4096 * 4096，这个取决于设备型号）。</p>

<p>如果你想在单个纹理中显示一个比这大的图，即便图片已经存在于内存中了，你仍然会遇到很大的性能问题，因为Core Animation强制用CPU处理图片而不是更快的GPU。</p>

<p><code>CATiledLayer</code>为载入大图造成的性能问题提供了一个解决方案：将大图分解成小片然后将他们单独按需载入。</p>

<h4>6.7.1、小片裁剪</h4>

<p>这个示例中，我们将会从一个2048*2048分辨率的雪人图片入手。为了能够从CATiledLayer中获益，我们需要把这个图片裁切成许多小一些的图片。你可以通过代码来完成这件事情，但是如果你在运行时读入整个图片并裁切，那CATiledLayer这些所有的性能优点就损失殆尽了。理想情况下来说，最好能够逐个步骤来实现。</p>

<p>下面演示了一个简单的Mac OS命令行程序，它用CATiledLayer将一个图片裁剪成小图并存储到不同的文件中。</p>

<pre><code>#import &lt;AppKit/AppKit.h&gt;

int main(int argc, const char * argv[])
{
    @autoreleasepool{
        ￼// 处理错误参数
        if (argc &lt; 2) {
            NSLog(@"TileCutter arguments: inputfile");
            return 0;
        }

        // 输入文件
        NSString *inputFile = [NSString stringWithCString:argv[1] encoding:NSUTF8StringEncoding];

        // 设置小片尺寸
        CGFloat tileSize = 256; 
        NSString *outputPath = [inputFile stringByDeletingPathExtension];

        // 读取图片
        NSImage *image = [[NSImage alloc] initWithContentsOfFile:inputFile];
        NSSize size = [image size];
        NSArray *representations = [image representations];
        if ([representations count]){
            NSBitmapImageRep *representation = representations[0];
            size.width = [representation pixelsWide];
            size.height = [representation pixelsHigh];
        }
        NSRect rect = NSMakeRect(0.0, 0.0, size.width, size.height);
        CGImageRef imageRef = [image CGImageForProposedRect:&amp;rect context:NULL hints:nil];

        // 计算行数和列数
        NSInteger rows = ceil(size.height / tileSize);
        NSInteger cols = ceil(size.width / tileSize);

        // 生成小片
        for (int y = 0; y &lt; rows; ++y) {
            for (int x = 0; x &lt; cols; ++x) {
            // 解压小片图像
            CGRect tileRect = CGRectMake(x*tileSize, y*tileSize, tileSize, tileSize);
            CGImageRef tileImage = CGImageCreateWithImageInRect(imageRef, tileRect);

            // 转换成jpeg数据
            NSBitmapImageRep *imageRep = [[NSBitmapImageRep alloc] initWithCGImage:tileImage];
            NSData *data = [imageRep representationUsingType: NSJPEGFileType properties:nil];
            CGImageRelease(tileImage);

            // 保存文件
            NSString *path = [outputPath stringByAppendingFormat: @"_%02i_%02i.jpg", x, y];
            [data writeToFile:path atomically:NO];
            }
        }
    }
    return 0;
}
</code></pre>

<p>这个程序将2048 * 2048分辨率的雪人图案裁剪成了64个不同的256 * 256的小图。（256 * 256是CATiledLayer的默认小图大小，默认大小可以通过tileSize属性更改）。程序接受一个图片路径作为命令行的第一个参数。我们可以在编译的scheme将路径参数硬编码然后就可以在Xcode中运行了，但是以后作用在另一个图片上就不方便了。所以，我们编译了这个程序并把它保存到敏感的地方，然后从终端调用，如下面所示：</p>

<pre><code>&gt; path/to/TileCutterApp path/to/Snowman.jpg
</code></pre>

<p>这个程序相当基础，但是能够轻易地扩展支持额外的参数比如小图大小，或者导出格式等等。运行结果是64个新图的序列，如下面命名：</p>

<pre><code>Snowman_00_00.jpg   
Snowman_00_01.jpg
Snowman_00_02.jpg
...
Snowman_07_07.jpg
</code></pre>

<p>既然我们有了裁切后的小图，我们就要让iOS程序用到他们。CATiledLayer很好地和UIScrollView集成在一起。除了设置图层和滑动视图边界以适配整个图片大小，我们真正要做的就是实现-drawLayer:inContext:方法，当需要载入新的小图时，CATiledLayer就会调用到这个方法。</p>

<p>小例子：一个简单的滚动CATiledLayer实现</p>

<pre><code>#import "ViewController.h"
#import &lt;QuartzCore/QuartzCore.h&gt;

@interface ViewController ()

@property (nonatomic, weak) IBOutlet UIScrollView *scrollView;

@end

@implementation ViewController

- (void)viewDidLoad
{   
    [super viewDidLoad];
    // 添加小片图层
    CATiledLayer *tileLayer = [CATiledLayer layer];￼
    tileLayer.frame = CGRectMake(0, 0, 2048, 2048);
    tileLayer.delegate = self; [self.scrollView.layer addSublayer:tileLayer];

    // 配置滚动视图
    self.scrollView.contentSize = tileLayer.frame.size;

    // 绘制图层
    [tileLayer setNeedsDisplay];
}

- (void)drawLayer:(CATiledLayer *)layer inContext:(CGContextRef)ctx
{
    //determine tile coordinate
    CGRect bounds = CGContextGetClipBoundingBox(ctx);
    NSInteger x = floor(bounds.origin.x / layer.tileSize.width);
    NSInteger y = floor(bounds.origin.y / layer.tileSize.height);

    //load tile image
    NSString *imageName = [NSString stringWithFormat: @"Snowman_%02i_%02i, x, y];
    NSString *imagePath = [[NSBundle mainBundle] pathForResource:imageName ofType:@"jpg"];
    UIImage *tileImage = [UIImage imageWithContentsOfFile:imagePath];

    // 绘制
    UIGraphicsPushContext(ctx);
    [tileImage drawInRect:bounds];
    UIGraphicsPopContext();
}
@end
</code></pre>

<p><img src="http://github-octopress.qiniudn.com/CoreAnimationAdvanced6.11.png" alt="Mou icon" /></p>

<p>当你滑动这个图片，你会发现当CATiledLayer载入小图的时候，他们会淡入到界面中。这是CATiledLayer的默认行为。也可以用fadeDuration属性改变淡入时长或者直接禁用掉。</p>

<p>CATiledLayer（不同于大部分的UIKit和Core Animation方法）支持多线程绘制，-drawLayer:inContext:方法可以在多个线程中同时地并发调用，所以请确保这个方法中实现的绘制代码是线程安全的。</p>

<h4>6.7.2、Retina小图</h4>

<p>这些小图并不是Retina的分辨率显示的。</p>

<p>为了以屏幕的原生分辨率来渲染CATiledLayer，我们需要设置图层的contentsScale来匹配UIScreen的scale属性：</p>

<pre><code>tileLayer.contentsScale = [UIScreen mainScreen].scale;
</code></pre>

<p>有趣的是，tileSize是以像素为单位，而不是点，所以增大了contentsScale就自动有了默认的小图尺寸（现在它是128 * 128的点而不是256 * 256）。</p>

<p>所以，我们不需要手工更新小图的尺寸或是在Retina分辨率下指定一个不同的小图。我们需要做的是适应小图渲染代码以对应安排scale的变化，然而：</p>

<pre><code>//determine tile coordinate
CGRect bounds = CGContextGetClipBoundingBox(ctx);
CGFloat scale = [UIScreen mainScreen].scale;
NSInteger x = floor(bounds.origin.x / layer.tileSize.width * scale);
NSInteger y = floor(bounds.origin.y / layer.tileSize.height * scale);
</code></pre>

<p>通过这个方法纠正scale也意味着我们的雪人图将以一半的大小渲染在Retina设备上（总尺寸是1024 * 1024，而不是2048 * 2048）。</p>

<p>这个通常都不会影响到用CATiledLayer正常显示的图片类型（比如照片和地图，他们在设计上就是要支持放大缩小，能够在不同的缩放条件下显示）。</p>

<h3>6.8、CAEmitterLayer</h3>

<p>在iOS 5中，苹果引入了一个新的CALayer子类叫做CAEmitterLayer。</p>

<p>CAEmitterLayer是一个高性能的粒子引擎，被用来创建实时例子动画如：烟雾，火，雨等等这些效果。</p>

<p>一个小例子：用CAEmitterLayer创建爆炸效果</p>

<pre><code>#import "ViewController.h"
#import &lt;QuartzCore/QuartzCore.h&gt;

@interface ViewController ()

@property (nonatomic, weak) IBOutlet UIView *containerView;

@end


@implementation ViewController

- (void)viewDidLoad
{
    [super viewDidLoad];
￼
    // 创建粒子发射图层
    CAEmitterLayer *emitter = [CAEmitterLayer layer];
    emitter.frame = self.containerView.bounds;
    [self.containerView.layer addSublayer:emitter];

    // 配置图层
    emitter.renderMode = kCAEmitterLayerAdditive;
    emitter.emitterPosition = CGPointMake(emitter.frame.size.width / 2.0,       emitter.frame.size.height / 2.0);

    // 创建一个粒子模板
    CAEmitterCell *cell = [[CAEmitterCell alloc] init];
    cell.contents = (__bridge id)[UIImage imageNamed:@"Spark.png"].CGImage;
    cell.birthRate = 150;
    cell.lifetime = 5.0;
    cell.color = [UIColor colorWithRed:1 green:0.5 blue:0.1 alpha:1.0].CGColor;
    cell.alphaSpeed = -0.4;
    cell.velocity = 50;
    cell.velocityRange = 50;
    cell.emissionRange = M_PI * 2.0;

    // 添加粒子模板到图层
    emitter.emitterCells = @[cell];
}
@end
</code></pre>

<p><img src="http://github-octopress.qiniudn.com/CoreAnimationAdvanced6.12a.png" alt="Mou icon" /></p>

<p><code>CAEMitterCell</code>的属性基本上可以分为三种：</p>

<ul>
<li><p>粒子的某属性的初始值。比如，color属性指定了一个可以混合图片内容颜色的混合色。在示例中，我们将它设置为桔色。</p></li>
<li><p>粒子某属性的变化范围。比如emissionRange属性的值是2π，这意味着例子可以从360度任意位置反射出来。如果指定一个小一些的值，就可以创造出一个圆锥形</p></li>
<li><p>指定值在时间线上的变化。比如，在示例中，我们将alphaSpeed设置为-0.4，就是说例子的透明度每过一秒就是减少0.4，这样就有发射出去之后逐渐小时的效果。</p></li>
</ul>


<p>CAEmitterLayer的属性它自己控制着整个例子系统的位置和形状。一些属性比如birthRate，lifetime和celocity，这些属性在CAEmitterCell中也有。这些属性会以相乘的方式作用在一起，这样你就可以用一个值来加速或者扩大整个例子系统。</p>

<p>其他值得提到的属性有以下这些：</p>

<pre><code>preservesDepth，是否将3D例子系统平面化到一个图层（默认值）或者可以在3D空间中混合其他的图层

renderMode，控制着在视觉上粒子图片是如何混合的。例子中设置为kCAEmitterLayerAdditive。这样实现了这样一个效果：合并例子重叠部分的亮度使得看上去更亮。如果设置为默认的kCAEmitterLayerUnordered，效果就没那么好看了.
</code></pre>

<p><img src="http://github-octopress.qiniudn.com/CoreAnimationAdvanced6.12.png" alt="Mou icon" /></p>

<h3>6.9、CAEAGLLayer</h3>

<p>当iOS要处理高性能图形绘制时就是用OpenGL。</p>

<p>OpenGL提供了Core Animation的基础，它是底层的C接口，直接和iPhone，iPad的硬件通信，它没有对象或图层的概念，只是简单地处理三角形。</p>

<p>OpenGL中所有东西都是3D空间中有颜色和纹理的三角形。</p>

<p>为了能够以高性能使用Core Animation，需要判断到底需要绘制哪种内容（矢量图形，例子，文本等），然后选择合适的图层去呈现这些内容，不过Core Animation中只有部分类型的内容是被高度优化的；如果你想绘制的东西并不能找到标准的图层类，同时想要得到高性能就比较费事情了。因为OpenGL根本不会对你的内容进行假设，它能够绘制得相当快。</p>

<p>利用OpenGL，你可以绘制任何你知道必要的集合信息和形状逻辑的内容。所以很多游戏都喜欢用OpenGL（这些情况下，Core Animation的限制就明显了：它优化过的内容类型并不一定能满足需求），但是这样依赖，方便的高度抽象接口就没了。</p>

<p>在iOS 5中，苹果引入了一个新的框架叫做GLKit，它去掉了一些设置OpenGL的复杂性，提供了一个叫做CLKView的UIView的子类，帮你处理大部分的设置和绘制工作。前提是各种各样的OpenGL绘图缓冲的底层可配置项仍然需要你用CAEAGLLayer完成，它是CALayer的一个子类，用来显示任意的OpenGL图形。</p>

<p>大部分情况下都不需要手动设置CAEAGLLayer（假设用GLKView），现在的标准做法是设置一个OpenGL ES 2.0的上下文。</p>

<p>尽管不需要GLKit也可以做到这一切，但是GLKit囊括了很多额外的工作，比如设置顶点和片段着色器，同时在运行时载入到图形硬件中。编写GLSL代码和设置EAGLayer没有什么关系，所以可以用GLKBaseEffect类将着色逻辑抽象出来。</p>

<p>小例子：用CAEAGLLayer绘制一个三角形</p>

<pre><code>#import "ViewController.h"
#import &lt;QuartzCore/QuartzCore.h&gt;
#import &lt;GLKit/GLKit.h&gt;

@interface ViewController ()

@property (nonatomic, weak) IBOutlet UIView *glView;
@property (nonatomic, strong) EAGLContext *glContext;
@property (nonatomic, strong) CAEAGLLayer *glLayer;
@property (nonatomic, assign) GLuint framebuffer;
@property (nonatomic, assign) GLuint colorRenderbuffer;
@property (nonatomic, assign) GLint framebufferWidth;
@property (nonatomic, assign) GLint framebufferHeight;
@property (nonatomic, strong) GLKBaseEffect *effect;
</code></pre>

<p>￼
    @end</p>

<pre><code>@implementation ViewController

- (void)setUpBuffers
{
    //set up frame buffer
    glGenFramebuffers(1, &amp;_framebuffer);
    glBindFramebuffer(GL_FRAMEBUFFER, _framebuffer);

    //set up color render buffer
    glGenRenderbuffers(1, &amp;_colorRenderbuffer);
    glBindRenderbuffer(GL_RENDERBUFFER, _colorRenderbuffer);
    glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_RENDERBUFFER, _colorRenderbuffer);
    [self.glContext renderbufferStorage:GL_RENDERBUFFER fromDrawable:self.glLayer];
    glGetRenderbufferParameteriv(GL_RENDERBUFFER, GL_RENDERBUFFER_WIDTH, &amp;_framebufferWidth);
    glGetRenderbufferParameteriv(GL_RENDERBUFFER, GL_RENDERBUFFER_HEIGHT, &amp;_framebufferHeight);

    //check success
    if (glCheckFramebufferStatus(GL_FRAMEBUFFER) != GL_FRAMEBUFFER_COMPLETE) {
        NSLog(@"Failed to make complete framebuffer object: %i", glCheckFramebufferStatus(GL_FRAMEBUFFER));
    }
}

- (void)tearDownBuffers
{
    if (_framebuffer) {
        //delete framebuffer
        glDeleteFramebuffers(1, &amp;_framebuffer);
        _framebuffer = 0;
    }

    if (_colorRenderbuffer) {
        //delete color render buffer
        glDeleteRenderbuffers(1, &amp;_colorRenderbuffer);
        _colorRenderbuffer = 0;
    }
}

- (void)drawFrame {
    //bind framebuffer &amp; set viewport
    glBindFramebuffer(GL_FRAMEBUFFER, _framebuffer);
    glViewport(0, 0, _framebufferWidth, _framebufferHeight);

    //bind shader program
    [self.effect prepareToDraw];

    //clear the screen
    glClear(GL_COLOR_BUFFER_BIT); glClearColor(0.0, 0.0, 0.0, 1.0);

    //set up vertices
    GLfloat vertices[] = {
        -0.5f, -0.5f, -1.0f, 0.0f, 0.5f, -1.0f, 0.5f, -0.5f, -1.0f,
    };

    //set up colors
    GLfloat colors[] = {
        0.0f, 0.0f, 1.0f, 1.0f, 0.0f, 1.0f, 0.0f, 1.0f, 1.0f, 0.0f, 0.0f, 1.0f,
    };

    //draw triangle
    glEnableVertexAttribArray(GLKVertexAttribPosition);
    glEnableVertexAttribArray(GLKVertexAttribColor);
    glVertexAttribPointer(GLKVertexAttribPosition, 3, GL_FLOAT, GL_FALSE, 0, vertices);
    glVertexAttribPointer(GLKVertexAttribColor,4, GL_FLOAT, GL_FALSE, 0, colors);
    glDrawArrays(GL_TRIANGLES, 0, 3);

    //present render buffer
    glBindRenderbuffer(GL_RENDERBUFFER, _colorRenderbuffer);
    [self.glContext presentRenderbuffer:GL_RENDERBUFFER];
}

- (void)viewDidLoad
{
    [super viewDidLoad];
    //set up context
    self.glContext = [[EAGLContext alloc] initWithAPI: kEAGLRenderingAPIOpenGLES2];
    [EAGLContext setCurrentContext:self.glContext];

    //set up layer
    self.glLayer = [CAEAGLLayer layer];
    self.glLayer.frame = self.glView.bounds;
    [self.glView.layer addSublayer:self.glLayer];
    self.glLayer.drawableProperties = @{kEAGLDrawablePropertyRetainedBacking:@NO, kEAGLDrawablePropertyColorFormat: kEAGLColorFormatRGBA8};

    //set up base effect
    self.effect = [[GLKBaseEffect alloc] init];

    //set up buffers
    [self setUpBuffers];

    //draw frame
    [self drawFrame];
}

- (void)viewDidUnload
{
    [self tearDownBuffers];
    [super viewDidUnload];
}

- (void)dealloc
{
    [self tearDownBuffers];
    [EAGLContext setCurrentContext:nil];
}
@end
</code></pre>

<p><img src="http://github-octopress.qiniudn.com/CoreAnimationAdvanced6.13.png" alt="Mou icon" /></p>

<p>在一个真正的OpenGL应用中，我们可能会用NSTimer或CADisplayLink周期性地每秒钟调用-drawRrame方法60次，同时会将几何图形生成和绘制分开以便不会每次都重新生成三角形的顶点（这样也可以让我们绘制其他的一些东西而不是一个三角形而已），不过上面这个例子已经足够演示了绘图原则了。</p>

<h3>6.10、AVPlayerLayer</h3>

<p>AVPlayerLayer不是Core Animation框架的一部分，它是由AVFoundation提供的，它和Core Animation紧密地结合在一起，提供了一个CALayer子类来显示自定义的内容类型。</p>

<p>AVPlayerLayer是用来在iOS上播放视频的。</p>

<p>它是高级接口例如MPMoivePlayer的底层实现，提供了显示视频的底层控制。</p>

<p>AVPlayerLayer的使用相当简单：</p>

<pre><code>用+playerLayerWithPlayer:方法创建一个已经绑定了视频播放器的图层

或者可以先创建一个图层，然后用player属性绑定一个AVPlayer实例。
</code></pre>

<p>小例子：用AVPlayerLayer播放视频</p>

<pre><code>#import "ViewController.h"
#import &lt;QuartzCore/QuartzCore.h&gt;
#import &lt;AVFoundation/AVFoundation.h&gt;

@interface ViewController ()

@property (nonatomic, weak) IBOutlet UIView *containerView; @end

@implementation ViewController

- (void)viewDidLoad
{
    [super viewDidLoad];
    // 获取视频URL
    NSURL *URL = [[NSBundle mainBundle] URLForResource:@"Ship" withExtension:@"mp4"];

    // 创建播放器和播放器图层
    AVPlayer *player = [AVPlayer playerWithURL:URL];
    AVPlayerLayer *playerLayer = [AVPlayerLayer playerLayerWithPlayer:player];

    // 设置播放器图层的frame并绑定在视图上
    playerLayer.frame = self.containerView.bounds;
    [self.containerView.layer addSublayer:playerLayer];

    // 播放视频
    [player play];
}
@end
</code></pre>

<p><img src="http://github-octopress.qiniudn.com/CoreAnimationAdvanced6.14.png" alt="Mou icon" /></p>

<p>用代码创建了一个AVPlayerLayer，把它添加到了一个容器视图中，而不是直接在controller中的主视图上添加。</p>

<p>这样是为了使得图层在最中间；因为Core Animation并不支持自动大小和自动布局，一旦设备被旋转了我们就要手动重新放置位置。</p>

<p>又因为AVPlayerLayer是CALayer的子类，它继承了父类的所有特性。</p>

<p>小例子 给视频增加变换，边框和圆角</p>

<pre><code>- (void)viewDidLoad
{
    ...
    // 设置播放器图层frame并绑定在视图上
    playerLayer.frame = self.containerView.bounds;
    [self.containerView.layer addSublayer:playerLayer];

    // 变换图层
    CATransform3D transform = CATransform3DIdentity;
    transform.m34 = -1.0 / 500.0;
    transform = CATransform3DRotate(transform, M_PI_4, 1, 1, 0);
    playerLayer.transform = transform;
￼
    // 添加圆角和边框
    playerLayer.masksToBounds = YES;
    playerLayer.cornerRadius = 20.0;
    playerLayer.borderColor = [UIColor redColor].CGColor;
    playerLayer.borderWidth = 5.0;

    // 播放视频
    [player play];
}
</code></pre>

<p><img src="http://github-octopress.qiniudn.com/CoreAnimationAdvanced6.15.png" alt="Mou icon" /></p>
]]></content>
  </entry>
  
</feed>
